{"pages":[],"posts":[{"title":"Pet-Project-web-clone-board-add","text":"개요웹에 클론코딩 페이지를 추가하기까지의 정리 현황[게시판으로 가는 기능 추가] [게시판 페이지 추가] 추가 내용main/clone_board.py 추가template/main/clone_board.html 추가 clone_board.html 코드123456789101112131415161718192021222324252627282930313233343536373839{% extends 'main/clone_base.html' %}{% block content %}&lt;html&gt; &lt;body&gt; &lt;div class=&quot;container my-3&quot;&gt; &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr class=&quot;thead-dark&quot;&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;내용&lt;/th&gt; &lt;!--th&gt;작성일시&lt;/th!--&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {% if content_list %} {% for content in content_list %} &lt;tr&gt; &lt;td&gt;{{ loop.index }}&lt;/td&gt; &lt;td&gt; {{ content['board_content'] }} &lt;/tr&gt; {% endfor %} {% else %} &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;너에게 받은만큼 더 행복해질게&lt;/td&gt; &lt;/tr&gt; {% endif %} &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;{% endblock %} clone_board.html 설명 clone_board.py 파일에서 데이터베이스에서부터 입력한 내용 (board_content_list)을 가져와html에 전달해주고 이를 모두 출력한다.(참고 사이트 : https://wikidocs.net/81050) 앞으로 추가할 것 기능 손보기 글쓴 시간 추가 디자인 수정(부트스트랩 변경 예상) 글쓰기 수정 삭제 사진 업로드 기능","link":"/2021/06/08/2021-05/Pet-Project-web-add-clone-board/"},{"title":"Pet-Project-web-clone-coding","text":"개요웹에 클론코딩 페이지를 추가하기까지의 정리 하려는 것 커뮤니티 사이트 clone coding 반려동물 기록 사이트 (고려중) 초기 설정main/clone_main.py 추가template/main/clone_main.html 추가template/main/clone_base.html 추가 설명게시판, 글쓰기(사진업로드 가능) 등 기능을 추가한다. 앞으로 추가할 것 게시판 기능 글쓰기 기능","link":"/2021/06/07/2021-05/Pet-Project-web-add-clone-coding-page/"},{"title":"Pet-Project-web_add_search_dissmiss","text":"개요이전에 추가하지 못했던 기능 및 프로젝트 종료 및 새 프로젝트 진행 현황검색 버튼을 눌러 입력한 정보를 forms를 통해 입력받고입력받은 값을 이용해 넷플릭스를 통해 크롤링하여이미지로 출력을 하는 것 까지 완료했다.이에 대한 설명은 이전 포스트에 적어둠.https://praisebak.github.io/2021/05/17/Pet-Project-web-add-search/ 프로젝트 종료시험기간, 과제로 바빠 업로드하지 못했는데그 동안 이번 프로젝트을 시작은 했지만 그닥 완성됐을 때 모양새가 그닥 안좋아보였다. 실제로 웹에서 서비스를 임시로 한다고 가정했을 때 저작권 넷플릭스에서 새로나온 회차들이 한눈에 보이지않는다고 하더라도 굳이 이 웹페이지에 로그인해서 사용할 동기가 없는 것. 넷플릭스의 검색기능을 이용하려니 직접 로그인을 해야하는데 멤버쉽이 만료됐는데 넷플릭스를 보질 않아서 돈이 아까움 등의 이유로 이 프로젝트는 여기까지 종료하도록 하고친구가 커뮤니티의 클론코딩을 해보는게 어떻겠는가하였는데뭔가 있어보이고 재밌어보이므로 다음 프로젝트는 디시인사이드의 클론코딩을 진행하려고 한다.","link":"/2021/05/30/2021-05/Pet-Project-web-add-search-dismiss/"},{"title":"Pet-Project-web_add_search","text":"개요웹에 검색기능을 추가하기까지의 정리 현재 상황 하려는 것위 그림에서 버튼을 누르면 입력란에 입력된 텍스트를 코드에서 가공해야하는데입력된 텍스트를 가져오는 것에서 막힘 해결 (0522)html에 form을 추가해서 url을 통해 정보를 받아 올 수 있도록 수정 show_program_list.py 코드1234567891011121314151617181920from flask import Blueprint, request,url_for, render_template, flash, request, session, gimport app.umshow_program_list_bp = Blueprint('show_program_list', __name__, url_prefix='/')@show_program_list_bp.route('/show_program_list', methods=['GET','POST'])def show_program_list(data = &quot;&quot;): data = request.args.get('search') if data != None: from app.__init__ import crawl url = crawl.netflixSearch(data) data = url[0] if data == None: data = &quot;&quot;; return render_template('/main/show_program_list.html',data = data) show_program_list.html 코드123456789101112131415161718{% extends 'main/base.html' %}{% block content %}&lt;div class=&quot;container my-3&quot;&gt;&lt;!-- ------------------------------ [edit] -------------------------------- --&gt; &lt;img src ={{data}}&gt; &lt;div class=&quot;row justify-content-end my-3&quot;&gt; &lt;div class=&quot;col-4 input-group&quot;&gt; &lt;form action=&quot;show_program_list&quot; method = &quot;get&quot;&gt; &lt;input placeholder=&quot;input text : &quot; name = &quot;search&quot; required /&gt; &lt;button&gt;검색&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- ---------------------------------------------------------------------- --&gt;{% endblock %} 설명검색란에 입력한 텍스트를 넷플릭스에서 검색해서 해당하는 프로그램 이미지를 가져옴(크롤링) 앞으로 추가할 것 검색한 프로그램들 즐겨찾기할 수 있는 기능 추가 검색 시 한번에 프로그램을 10개씩 보여주고 더보기누르면 더 보여주도록 (최대 50개 프로그램) 즐겨찾기한 프로그램들이 최근에 언제 올라왔고 몇화까지 올라왔는지 갱신","link":"/2021/05/17/2021-05/Pet-Project-web-add-search/"},{"title":"B1476","text":"개요백준 문제 1476번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 20분https://www.acmicpc.net/problem/1476 문제준규가 사는 나라는 우리가 사용하는 연도와 다른 방식을 이용한다. 준규가 사는 나라에서는 수 3개를 이용해서 연도를 나타낸다. 각각의 수는 지구, 태양, 그리고 달을 나타낸다. 지구를 나타내는 수를 E, 태양을 나타내는 수를 S, 달을 나타내는 수를 M이라고 했을 때, 이 세 수는 서로 다른 범위를 가진다. (1 ≤ E ≤ 15, 1 ≤ S ≤ 28, 1 ≤ M ≤ 19) 우리가 알고있는 1년은 준규가 살고있는 나라에서는 1 1 1로 나타낼 수 있다. 1년이 지날 때마다, 세 수는 모두 1씩 증가한다. 만약, 어떤 수가 범위를 넘어가는 경우에는 1이 된다. 예를 들어, 15년은 15 15 15로 나타낼 수 있다. 하지만, 1년이 지나서 16년이 되면 16 16 16이 아니라 1 16 16이 된다. 이유는 1 ≤ E ≤ 15 라서 범위를 넘어가기 때문이다. E, S, M이 주어졌고, 1년이 준규가 사는 나라에서 1 1 1일때, 준규가 사는 나라에서 E S M이 우리가 알고 있는 연도로 몇 년인지 구하는 프로그램을 작성하시오. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std; void solve(){ int answerE = 0,answerS = 0,answerM = 0; int eMax = 15; int sMax = 28; int mMax = 19; int year = 0; int curE = 0; int curS = 0; int curM = 0; cin &gt;&gt; answerE &gt;&gt; answerS &gt;&gt; answerM; while(1) { curE++; curS++; curM++; year++; if(curE &gt; eMax) { curE = 1; } if(curS &gt; sMax) { curS = 1; } if(curM &gt; mMax) { curM = 1; } if(answerE == curE &amp;&amp; answerS == curS &amp;&amp; answerM == curM) { cout &lt;&lt; year; break; } } }int main(){ solve();} 풀이 뭔가 규칙성을 찾아서 풀기 보다는 그냥 문제의 조건에 맞춰 E,S,M 값과 년도를 늘려나가는데,입력된 값과 현재 E,S,M이 일치하면 년도를 출력하면 되는 완전탐색 문제임. 배울 점, 메모완전탐색인 것을 알고 풀었기 때문에 쉬운 문제라고 생각함.유형을 아직 익히는 것이기 때문에 유형과 문제를 1:1로 매칭시키는 것이 필요함.","link":"/2021/05/30/2021-05/b1476/"},{"title":"Pet-Project-web-게시글 추가 기능 및 날짜 추가","text":"개요웹에 클론코딩 페이지를 추가하기까지의 정리 현황게시글 추가와 게시글에 날짜를 추가하였다. [글쓰기 버튼 추가 및 작성일시 추가][글쓰기 눌렀을 때 화면] 소스 코드 수정 현황 clone_board.py board.html clone_board.py 코드123456789101112131415161718192021222324252627282930313233from threading import main_threadfrom flask import Blueprint, request, render_template, flash, redirect, url_for, g,sessionfrom app.module.dbModule import Databasefrom app.forms.forms import ContentAddForm, UserAddCheckfrom datetime import datetimeclone_board_bp = Blueprint('clone_board',__name__,url_prefix='/clone_board')@clone_board_bp.route('/list',methods=['POST','GET'])def list(): db = Database() content_list = db.executeAll(&quot;SELECT * FROM board_content_table&quot;) print(content_list) return render_template('/main/board.html',content_list=content_list)@clone_board_bp.route('/add',methods=['POST','GET'])def add(): form = ContentAddForm() title = form.content_title.data text = form.content_text.data if request.method == 'POST' and not form.validate_on_submit() and ((title == &quot;&quot;) or (text == &quot;&quot;)): error = &quot;데이터 양식이 맞지 않습니다&quot; flash(error) elif request.method == 'POST' and not((title == &quot;&quot;) or (text == &quot;&quot;)): db = Database() db.execute(&quot;&quot;&quot;INSERT INTO board_content_table (board_content,board_content_title,write_time) VALUES ('%s','%s','%s')&quot;&quot;&quot; % (text, title,datetime.now())) db.commit() return redirect(url_for(&quot;clone_board.list&quot;)) return render_template('/main/board_add.html',form=form) clone_board.py 설명 게시글 리스트를 보여주는 list 페이지와 게시글 추가 버튼을 눌렀을 때의 add 페이지로 분리 게시글 리스트 페이지에서는 항상 디비로부터 가져온 정보를 모두 출력함(아직 페이징 기능 미구현) 게시글 추가 페이지에서는 제목과 내용을 입력하면 데이터베이스에 추가함 제목이나 내용을 입력하지 않으면 에러 출력함 데이터베이스에 제대로 입력됐다면 list 페이지로 재연결해줌clone_board.html 코드 123456789101112131415161718192021222324252627282930313233343536{% extends 'main/clone_base.html' %}{% block content %}&lt;html&gt; &lt;body&gt; &lt;div class=&quot;container my-3&quot;&gt; &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr class=&quot;thead-dark&quot;&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성일시&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {% if content_list %} {% for content in content_list %} &lt;tr&gt; &lt;td&gt;{{ content['board_content_idx'] }}&lt;/td&gt; &lt;td&gt; {{ content['board_content'] }} &lt;/td&gt; &lt;td&gt;{{ content['write_time'] }}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=&quot;btns&quot;&gt; &lt;li&gt;&lt;a href=&quot;/clone_board/add&quot; class=&quot;button big&quot;&gt;글쓰기&lt;/a&gt;&lt;/li&gt; &lt;/div&gt; 이하 생략 clone_board.html 설명 리스트 페이지의 작성글 인덱스,내용,작성 일시를 출력 글쓰기 버튼 추가 clone_board_add.html 코드1234567891011121314151617생략&lt;div class=&quot;container my-3&quot;&gt; &lt;form method=&quot;post&quot; class=&quot;post-form&quot;&gt; {{ form.csrf_token }} {% include &quot;checklist_form_errors.html&quot; %} Title:&amp;nbsp &lt;input type=&quot;content_title&quot; class=&quot;form-control&quot; name=&quot;content_title&quot; id=&quot;content_title&quot;&gt; &lt;form action=&quot;{{ url_for('clone_board.add') }}&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;content_text&quot; style=&quot;font-size:16px;&quot; &gt;Content:&lt;/label&gt; &lt;textarea name=&quot;content_text&quot; id=&quot;content_text&quot; rows=&quot;15&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;submit&quot; style=&quot;font-size:16px;&quot; value=&quot;등록&quot;&gt; &lt;/form&gt; &lt;/form&gt;생략 clone_board_add.html 설명 에러 출력 관련 처리 위한 코드 추가 제목과 내용 입력란 추가 등록 버튼을 누르면 forms 정보와 함께 clone_board add 메소드로 이동 향후 목표 기능 손보기 부트스트랩 변경(디자인 수정) 글 수정기능 부가적으로 패스워드 필요 글 삭제 부가적으로 패스워드 필요 사진 업로드 기능(글쓰기) 작성자 이름 추가(닉네임)","link":"/2021/06/09/2021-06/web-add-clone-add-board/"},{"title":"Pet-Project-web-0627-근황","text":"개요웹에 클론코딩 페이지를 추가하기까지의 정리 현황 게시글 리스트에 작성자 추가 비로그인인 경우 작성자에 ip가 표시됨(ip 일부) 로그인한 유저의 경우 작성자에 ip 미표시 로그인 기능 적용 로그인한 유저가 작성한 글은 해당 유저만 삭제가능 로그인한 유저는 비로그인 유저의 삭제,수정기능 이용불가 비로그인 유저의 글 수정 삭제는 비밀번호 입력 로그인 유저의 글 수정 삭제는 동일 유저라면 비밀번호 입력 X 댓글,대댓글에도 적용시킴 검색기능 페이징기능 추천,비추천 기능 추가 댓글,대댓글 기능 추가 검색,페이징 기능 작성자 추가, 로그인 적용(ip 유무로 로그인 비로그인 구분) 댓글 관련 소스 코드 및 설명앞으로 추가 및 링크 추가 예정! 향후 목표 사진 업로드 기능(글쓰기) 프로필 기능 ​","link":"/2021/06/26/2021-06/web-add-clone-board-0627-recent/"},{"title":"web-add-clone-board-modify-del","text":"title: Pet-Project-web-수정 및 삭제기능 추가category: pet projecttags: pet project date: 2021-06-09 4:55:01개요웹에 클론코딩 페이지를 추가하기까지의 정리 현황게시글 수정 및 게시글 삭제를 추가하였다. [글쓰기 버튼 추가 및 작성일시 추가][글쓰기 눌렀을 때 화면] 소스 코드 수정 현황 clone_board.py board_add.html board_content.html clone_board.py 코드123456789101112131415161718192021222324@clone_board_bp.route('/del/&lt;int:board_content_idx&gt;/')def delContent(board_content_idx): db = Database() db.execute(&quot;&quot;&quot;DELETE FROM board_content_table WHERE board_content_idx = %s&quot;&quot;&quot; %str(board_content_idx)) db.commit() return redirect(url_for(&quot;clone_board.list&quot;)) @clone_board_bp.route('/modify/&lt;int:board_content_idx&gt;/',methods=['POST','GET'])def modify(board_content_idx): db = Database() data = db.executeAll(&quot;&quot;&quot;SELECT * FROM board_content_table WHERE board_content_idx = %s&quot;&quot;&quot; %str(board_content_idx)) if request.method == 'POST': form = ContentAddForm() if form.validate_on_submit(): db.execute(&quot;&quot;&quot;UPDATE board_content_table SET write_time='%s',board_content_title='%s',board_content='%s' WHERE board_content_idx = '%s'&quot;&quot;&quot; % (datetime.now(),form.content_title.data,form.content_text.data,str(data[0]['board_content_idx']) )) db.commit() return redirect(url_for('clone_board.content',board_content_idx=board_content_idx)) else: form = ContentAddForm(content_title=data[0]['board_content_title'],content_text=data[0]['board_content']) return render_template('/main/board_add.html',form=form,board_content_idx=board_content_idx) clone_board.py 설명 일부 생략된 코드임을 유의 삭제 버튼을 누르면 DB에서 삭제 수정 버튼을 누르면 수정창(게시글 작성 재활용)을 띄워줌 수정창에서 등록을 눌렀다면(request = POST인 경우) db에 업데이트 해주고 수정된 내용을 보여줌 board_add.html 코드123456789101112131415161718생략&lt;div class=&quot;container my-3&quot;&gt; &lt;form method=&quot;post&quot; class=&quot;post-form&quot;&gt; {{ form.csrf_token }} {% include &quot;checklist_form_errors.html&quot; %} Title:&amp;nbsp &lt;input type=&quot;content_title&quot; class=&quot;form-control&quot; name=&quot;content_title&quot; id=&quot;content_title&quot; value={{ form.data.content_title or ''}}&gt; &lt;form action=&quot;{{ url_for('clone_board.list',board_content_idx=board_content_idx) if form.data.content_text else url_for('clone_board.list') }}&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;content_text&quot; style=&quot;font-size:16px;&quot;&gt;Content:&lt;/label&gt; &lt;textarea name=&quot;content_text&quot; id=&quot;content_text&quot; rows=&quot;15&quot;&gt;{{form.data.content_text or ''}}&lt;/textarea&gt; &lt;input type=&quot;submit&quot; style=&quot;font-size:16px;&quot; value=&quot;등록&quot;&gt; &lt;/form&gt; &lt;/form&gt; 생략 board_add.html 설명 조건문으로 수정모드일때와 글작성 모드를 forms의 값 유무로 판단하여 버튼을 눌렀을 때 연결할 url을 설정해줌 board_content.html 코드12345678910&lt;div class=&quot;btns&quot;&gt; &lt;div class=&quot;modify&quot;&gt; &lt;a href=&quot;{{ url_for('clone_board.modify',board_content_idx=content[0]['board_content_idx'])}}&quot; class=&quot;button&quot;&gt;수정&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;delete&quot;&gt; &lt;a href=&quot;{{ url_for('clone_board.delContent',board_content_idx=content[0]['board_content_idx']) }}&quot; class=&quot;button&quot;&gt; 삭제 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; board_content_html 설명 수정,삭제버튼 추가 향후 목표 기능 손보기 부트스트랩 변경(디자인 수정) 글 수정기능 패스워드 기능 추가 글 삭제 패스워드 기능 추가 사진 업로드 기능(글쓰기) 작성자 이름 추가(닉네임) 글 댓글 기능 추가 댓글 작성자 이름 댓글 패스워드 댓글 수정, 삭제","link":"/2021/06/10/2021-06/web-add-clone-board-modify-del/"},{"title":"백준 14889 스타트와 링크 JAVA","text":"문제링크 : https://www.acmicpc.net/problem/14889 오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다. 축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이고 신기하게도 N은 짝수이다. 이제 N/2명으로 이루어진 스타트 팀과 링크 팀으로 사람들을 나눠야 한다. BOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다. 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다. N=4이고, S가 아래와 같은 경우를 살펴보자. i\\j 1 2 3 4 1 1 2 3 2 4 5 6 3 7 1 2 4 3 4 5 예를 들어, 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우에 두 팀의 능력치는 아래와 같다. 스타트 팀: S12 + S21 = 1 + 4 = 5 링크 팀: S34 + S43 = 2 + 5 = 7 1, 3번이 스타트 팀, 2, 4번이 링크 팀에 속하면, 두 팀의 능력치는 아래와 같다. 스타트 팀: S13 + S31 = 2 + 7 = 9 링크 팀: S24 + S42 = 6 + 4 = 10 축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다. 풀이모든 경우의 수를 돌면서 최소 차이의 경우를 찾아내면 되는 문제 문제는 어떻게 구현할 것이냐인데 나도 이런 문제에서 모든 경우의 수를 어떻게 구하지? 하는 생각에 풀지 못하고 코드를 참조했었는데 지금와서는 모든 경우의 수를 구한다 -&gt; 백트래킹, DFS, 비트마스킹을 사용하면 어느정도 해소된다 생각한다. 어쨌건 풀이자체는 간단하다 백트래킹으로 모든 경우의 수에서 visit이면 start, !visit이면 link팀으로 생각하고 이 때 차이를 계산하고 차이가 적은 점수로 갱신해주면 된다. 풀이는 간단하지만 구현상에서 언제 visit을 false로 할 것인가 라던가 조금 섬세함이 필요한 문제 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.Scanner;public class Main{ static int MAX = 21; static int arr[][]; static boolean visit[]; static int N = 0; static int ans = 987654321; static int getScore(int array[]) { int result = 0; int len = N/2; for(int i=1;i&lt;=len;i++) { for(int j=i+1;j&lt;=len;j++) { result += arr[array[i]][array[j]]; result += arr[array[j]][array[i]]; } } return result; } static void setDiff() { int start[] = new int[N/2+1]; int link[] = new int[N/2+1]; int startIdx = 1; int linkIdx = 1; for(int i=1;i&lt;=N;i++) { if(visit[i]) { start[startIdx++]= i; } else { link[linkIdx++]= i; } } int startScore = getScore(start); int linkScore = getScore(link); int result = Math.abs(startScore - linkScore); if(result &lt; ans) { ans = result; } } static void dfs(int v,int count) { if(count == N/2) { setDiff(); } else { for(int i=v+1;i&lt;=N;i++) { if(!visit[i]) { visit[i] = true; dfs(i,count+1); } } } visit[v] = false; } public static void main(String [] args) { Scanner sc = new Scanner(System.in); N = sc.nextInt(); arr = new int[MAX][MAX]; visit = new boolean[MAX]; for(int i=1;i&lt;=N;i++) { for(int j=1;j&lt;=N;j++) { arr[i][j] = sc.nextInt(); } } sc.close(); dfs(0,0); System.out.println(ans); }} 메모모든 경우의 수를 생각해야한다(브루트 포스) -&gt; 백트래킹,DFS 생각해볼만 함","link":"/2021/07/14/2021-07/b14899/"},{"title":"백준 20055 컨베이어 벨트 위의 로봇 JAVA","text":"문제링크 : https://www.acmicpc.net/problem/20055 길이가 N인 컨베이어 벨트가 있고, 길이가 2N인 벨트가 이 컨베이어 벨트를 위아래로 감싸며 돌고 있다. 벨트는 길이 1 간격으로 2N개의 칸으로 나뉘어져 있으며, 각 칸에는 아래 그림과 같이 1부터 2N까지의 번호가 매겨져 있다. 벨트가 한 칸 회전하면 1번부터 2N-1번까지의 칸은 다음 번호의 칸이 있는 위치로 이동하고, 2N번 칸은 1번 칸의 위치로 이동한다. i번 칸의 내구도는 Ai이다. 위의 그림에서 1번 칸이 있는 위치를 “올리는 위치“, N번 칸이 있는 위치를 “내리는 위치“라고 한다. 컨베이어 벨트에 박스 모양 로봇을 하나씩 올리려고 한다. 로봇은 올리는 위치에만 올릴 수 있다. 언제든지 로봇이 내리는 위치에 도달하면 그 즉시 내린다. 로봇은 컨베이어 벨트 위에서 스스로 이동할 수 있다. 로봇을 올리는 위치에 올리거나 로봇이 어떤 칸으로 이동하면 그 칸의 내구도는 즉시 1만큼 감소한다. 컨베이어 벨트를 이용해 로봇들을 건너편으로 옮기려고 한다. 로봇을 옮기는 과정에서는 아래와 같은 일이 순서대로 일어난다. 벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다. 가장 먼저 벨트에 올라간 로봇부터, 벨트가 회전하는 방향으로 한 칸 이동할 수 있다면 이동한다. 만약 이동할 수 없다면 가만히 있는다. 로봇이 이동하기 위해서는 이동하려는 칸에 로봇이 없으며, 그 칸의 내구도가 1 이상 남아 있어야 한다. 올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올린다. 내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료한다. 그렇지 않다면 1번으로 돌아간다. 종료되었을 때 몇 번째 단계가 진행 중이었는지 구해보자. 가장 처음 수행되는 단계는 1번째 단계이다. 풀이문제를 이해를 조심스럽게 해야하는 문제 우선 맨앞에 추가한다던가 맨뒤에 있는 것을 뺀다거나 해야해서 Deque 자료구조를 사용하는 것이 편함 그 뒤에는 일련의 과정을 시키는대로 구현하면 됨 rotation 위 컨베이어 벨트에서 맨 마지막 로봇을 아래 컨베이어 벨트로 내림 아래 컨베이어 벨트의 첫번째 로봇을 위 컨베이어 벨트로 올림 move 로봇이 없고 등등 위 컨베이어 벨트에서 마지막에 가까운 로봇을 먼저 조건에 맞으면 이동시킴 로봇을 올릴 수 있으면 올린다 조건에 맞으면 종료 아니면 1번으로 돌아가 반복 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import java.util.Scanner;import java.util.ArrayDeque;import java.util.Deque;import java.util.Iterator;class Pair{ Integer key; Integer value; public Pair(int key,int value) { this.key = key; this.value = value; } public Integer getKey() { return this.key; } public Integer getValue() { return this.value; } public void setKey(int key) { this.key = key; } public void setValue(int val) { this.value = val; }}class Main{ static int N,K; static Deque&lt;Pair&gt; upBelt = new ArrayDeque&lt;&gt;(); static Deque&lt;Integer&gt; downBelt = new ArrayDeque&lt;&gt;(); static Scanner sc; static int countK = 0; static void inputFromIO() { sc = new Scanner(System.in); N = sc.nextInt(); K = sc.nextInt(); for(int i=0;i&lt;N;i++) { upBelt.add(new Pair(sc.nextInt(),0)); } for(int i=0;i&lt;N;i++) { downBelt.addFirst(sc.nextInt()); } } //회전할때는 내리는 위치에 있는애만 내리고 //올리는 애는 안올림 static void rotation() { int downFirst = downBelt.pollFirst(); Pair upLast = upBelt.pollLast(); int upLastVal = upLast.getKey(); downBelt.addLast(upLastVal); upBelt.addFirst(new Pair(downFirst,0)); Pair afterUpLast = upBelt.getLast(); if(afterUpLast.value == 1) { afterUpLast.value = 0; } } static void robotMove() { Iterator&lt;Pair&gt; iter = upBelt.descendingIterator(); //맨마지막은 어차피 못움직임(내리는 위치니까) Pair prev = iter.next(); int prevRobot = prev.getValue(); for(; iter.hasNext();) { Pair curBelt = iter.next(); if(prevRobot == 0 &amp;&amp; prev.getKey() &gt; 0 &amp;&amp; curBelt.getValue() == 1) { prev.setKey(prev.getKey()-1); curBelt.setValue(0); prev.setValue(1); if(prev.getKey() == 0) { countK++; } } prev = curBelt; prevRobot = curBelt.getValue(); } prevRobot = upBelt.getLast().value; if(prevRobot == 1) { upBelt.getLast().value = 0; } } static void robotAdd() { Pair first = upBelt.getFirst(); if(first.key &gt;= 1) { first.setValue(1); first.key--; if(first.key== 0) { countK++; } } } static void solve() { int level = 0; while(countK &lt; K) { //System.out.println(&quot;***********\\nbefore&quot;); //printAll(); rotation(); //System.out.println(&quot;\\nafter&quot;); //printAll(); robotMove(); //System.out.println(&quot;\\nafter robot move&quot;); //printAll(); robotAdd(); //System.out.println(&quot;\\nafter robot add&quot;); //printAll(); level++; //System.out.println(); //sc.next(); //countK = printAll(); } System.out.println(level); } public static void main(String args[]) { inputFromIO(); solve(); }} 메모문제 이해를 잘 못해서 한번 꼬였고 두번째 구현에서도 조금 시간이 걸렸음 구현력이 좀 떨어진다","link":"/2021/07/14/2021-07/b20055/"},{"title":"스프링부트 커뮤니티 사이트 설계 (mindaces 01)","text":"개요 스프링부트 공부 겸 펫 프로젝트를 시작해볼려고 한다. 만들려는 사이트는 커뮤니티 사이트로 우선 사이트에 접속하면 위와 같은 메인페이지가 나오도록 만들어 보려고 하는 것이 1차 목표이다. 아예 노베이스기 때문에 설명하기에 부족함이 많겠지만 설명할 때 애매한 부분같은 것을 알게될때까지 제대로 공부하여 제대로된 포스팅을 하는 것이 목표이다. 개발 환경스프링부트에는 여러가지 디펜던시라던가 결합할 수 있는 환경들이 무지막지하게 많은데 우선은 초기설정한 디펜던시는 다음과 같다.본인은 gradle이 최근에 개발된 프레임워크인 것 같아 gradle을 선택했다. 현재 목표 메인 화면 만들기","link":"/2021/07/20/2021-07/mindaces00/"},{"title":"스프링부트 커뮤니티 사이트 개발환경,reload 설정 (mindaces 02)","text":"개요개발하기에 앞서서 설치 및 환경설정을 해볼려고 한다. IDE는 인텔리제이 유료버전을 사용하고 있는데 인텔리제이에서도 몇가지 설정을 해야한다. 이번 포스팅에서는 위 두가지를 해볼려고 한다. 이번 포스팅에서 할 것 스프링부트 설치 IDE 설정 및 스프링부트 설정 SpringBootInitalize먼저 다음의 링크에 접속한다. https://start.spring.io/ 접속 후 다음 이미지와 같이 설정한다. 이후 GENERATE를 눌러 나오는 압축파일을 푼다. build.gradle는 다음과 같이 생성된다. 1234567891011121314151617181920212223242526272829303132333435plugins { id 'org.springframework.boot' version '2.5.2' id 'io.spring.dependency-management' version '1.0.11.RELEASE' id 'java'}group = 'com.mindaces'version = '0.0.1-SNAPSHOT'sourceCompatibility = '16'configurations { compileOnly { extendsFrom annotationProcessor }}repositories { mavenCentral()}dependencies { implementation 'org.springframework.boot:spring-boot-starter-data-jpa' implementation 'org.springframework.boot:spring-boot-starter-thymeleaf' implementation 'org.springframework.boot:spring-boot-starter-web' compileOnly 'org.projectlombok:lombok' developmentOnly 'org.springframework.boot:spring-boot-devtools' runtimeOnly 'mysql:mysql-connector-java' annotationProcessor 'org.projectlombok:lombok' testImplementation 'org.springframework.boot:spring-boot-starter-test'}test { useJUnitPlatform()} MYSQL 설정아직은 바로 실행하면 데이터베이스가 연결되지 않았다는 오류 메시지가 뜰 것이다. 해결방법은 시키는대로 데이터베이스를 연결하면 된다. 우선 MYSQL 실행해서 다음의 코드로 spring-demo-mysql 데이터베이스를 생성한다. 1CREATE DATABASE spring-demo-mysql default CHARACTER SET UTF8; 이후 아까 압축해제한 루트 폴더에서부터 src/main/ resources/application.properties 파일을 연다 파일을 열면 아직은 아무것도 없는 상황인데 여기에 다음을 입력해 데이터베이스에 관한 설정을 해주어야 한다. 1234spring.jpa.hibernate.ddl-auto=updatespring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:3306/spring-demo-mysql?serverTimezone=Asia/Seoul&amp;characterEncoding=UTF-8spring.datasource.username=유저네임spring.datasource.password=비밀번호 이 설정을 한 뒤에는 실행이 제대로 될 것이다. LOMBOK인텔리제이 IDE를 사용한다면 LOMBOK을 스프링부트 디펜던시에 추가한 뒤에 플러그인도 설치해주어야 한다. 인텔리제이에서 파일 -&gt; 설정 -&gt; 플러그인에 LOMBOK을 검색하여 설치한다. reload 설정앞으로 개발을 하면서 몇가지를 수정하게 될탠데 Springboot는 자체적으로 빌드도 느린데다가 일일이 재시작하기도 귀찮다 그래서 앞서 디펜던시에 추가한 SpringBoot devtools의 재시작기능을 사용할 것이다. 앞서 디펜던시에 추가된 상태여서 추가적인 것은 할 것이 없고 대신 인텔리제이에서 몇가지 설정을 해주어야 한다. 프로젝트 자동 빌드설정 -&gt; 빌드, 실행, 배포 -&gt; 컴파일러에 들어가서 프로젝트 자동 빌드를 체크해준다. 업데이트 설정오른쪽 상단에서 MindacesApplication을 클릭해 구성편집을 눌러 다음 이미지에서 처럼 설정해준다. 레지스트리 설정Ctrl + Shift + A를 눌러 검색창에 레지스트리를 검색해서 다음과 같이 설정한다(영어 버전이면 Registry 검색) 여기까지 한 뒤 앞으로 프로젝트를 디버깅 모드로 실행하면 코드 수정된 것이 알아서 반영된다. 선택 사항재시작이 자동으로 된 것은 좋은데 아무래도 수정하다가 중간에 재시작돼서 에러를 뿜어버리면 곤란하다. 그렇다고 프로젝트를 다시 키면 너무 오래걸리고 수동으로 갱신하게 하고 싶을 때가 있다. src/main/ resources/application.properties에 다음 한줄을 추가하면 된다. 1spring.devtools.restart.enabled=false 이후에는 프로젝트 빌드 Ctrl + F9를 누르면 변경사항이 갱신될 것이다. 여기까지가 reload 기능을 사용하는 방법에 대해서 알아봤다. 빌드를 꽤 빨리할 수 있다는 점에서 개발을 좀 더 원활하게 할 수 있게 해주는 설정인 것 같다!","link":"/2021/07/20/2021-07/mindaces01/"},{"title":"프로그래머스 2레벨 12905 가장 큰 정사각형 찾기","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12905 1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.) 풀이배열의 각 요소를 왼쪽,위,왼쪽 위의 값 중 최솟값 +1로 갱신하여 최대 크기를 구할 수 있다.최솟값인 이유는 정사각형이기 때문이다.현 위치에서 가능한 최대 정사각형의 크기를 저장한다는 점에서 메모라이제이션 느낌을 받았다. 코드1234567891011121314151617181920212223class Solution { public static int solution(int [][]board) { int answer = board[0][0]; int r = board.length; int c = board[0].length; for(int i=1;i&lt;r;i++) { for(int j=1;j&lt;c;j++) { if(board[i][j] == 1) { board[i][j] = Math.min(board[i-1][j],board[i-1][j-1]); board[i][j] = Math.min(board[i][j-1],board[i][j]) + 1; answer = Math.max(answer,board[i][j]); } } } return (int)Math.pow(answer,2); }} 메모문제는 간단한데 막상 풀려니 풀이가 떠오르지 않은 문제🙃스스로 풀었는가 : ❎","link":"/2021/07/15/2021-07/p12905/"},{"title":"programmers 17687 [3차] n진수 게임","text":"문제괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어“()()” 또는 “(())()” 는 올바른 괄호입니다.“)()(“ 또는 “(()(“ 는 올바르지 않은 괄호입니다.‘(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요. 풀이 시작괄호로 시작하는지 체크 닫힌괄호가 나올 수 있는 것은 아직 닫히지 않은 시작괄호가 있을 때 뿐임 이를 startCount 즉 시작괄호로 체크해줌 (==0 이면 모든 시작괄호가 잘 닫혔단 뜻) 코드123456789101112131415161718192021222324252627282930class Solution { boolean solution(String s) { boolean answer = true; int startCount = 0; for(int i=0;i&lt;s.length();i++) { if(s.charAt(i) == ')') { startCount++; } else { if(startCount &lt; 1) { return false; } startCount--; } } if(startCount != 0) { answer = false; } return answer; }} 메모스택을 사용해서 풀수도 있다는데 참고만 할 것","link":"/2021/08/01/2021-07/p12909/"},{"title":"프로그래머스 2레벨 12911 다음 큰 숫자 (브루트포스)","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12911 자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다. 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다. 예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다. 자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요. 풀이브루트포스 방식으로 조건에 맞는 값이 나올때까지 반복함 브루트포스 방식은 처음에 떠올랐지만 문자열로 처리해서 풀고싶어서 시도해보았으나 풀지 못함.. 코드123456789101112131415161718192021222324252627282930313233343536373839404142class Solution{ boolean isCollectOne(int n,int originCount) { if(countOne(n) == originCount) { return true; } return false; } int countOne(int n) { int count = 0; char[] bit = (Integer.toBinaryString(n)).toCharArray(); for(int i=0;i&lt;bit.length;i++) { if(bit[i] == '1') { count++; } } return count; } public int solution(int n) { int answer = 0; int num = n+1; int originCount = countOne(n); while(!isCollectOne(num++,originCount)) { } answer = num-1; return answer; }} 메모문자열로 푸는 방식은 우아하다기보다는 경우의 수가 3개정도 나오고 그에 대한 처리를 하는 방식이었음 뭔가 문제에서 유추할 수 있는 방식이 아니라 생각하여서 브루트포스로 푸는것도 나쁘지 않아보임","link":"/2021/07/15/2021-07/p12911/"},{"title":"programmers 12949 행렬의 곱셈","text":"개요요즘 블로그 글을 쓰는게 엄청 뜸했는데 기록이 정말정말 중요하다는 생각에 다시 열심히 써볼려고 함! 우선은 밀린 글부터 차근차근 써나갈 예정 문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12913 땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다. 예를 들면, | 1 | 2 | 3 | 5 | | 5 | 6 | 7 | 8 | | 4 | 3 | 2 | 1 | 로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다. 마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다. 풀이이전에 밟은 땅의 점수를 의미하는 tmp 변수를 이용한다. 문제에서 이전에 밟은 땅은 연속적으로 밟을 수 없다고 하였으므로 이 부분 주의하여 이전에 밟지 않은 땅만 계산한다. 이전에 밟은 땅 점수 + 현재 밟은 땅의 점수를 계산하여 가능한 모든 경우의 수에 최대값을 계산하면 되는 문제 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution { public String getNDigitNum(int n,int digit) { StringBuilder sb = new StringBuilder(); int curNumber = n; if(curNumber == 0) { return &quot;0&quot;; } while(curNumber &gt; 0) { if(curNumber % digit &lt; 10) { sb.append(curNumber % digit); } else { sb.append((char)(curNumber % digit - 10 + 'A')); } curNumber /= digit; } return sb.reverse().toString(); } //0, 1, 1, 0, 1, 1, 1, 0, 0 //digit,number,people,count public String solution(int n, int t, int m, int p) { String nDigitString; StringBuilder answerStrBuild = new StringBuilder(); int curT = 1; int num=0; int countT = 0; while(true) { nDigitString = getNDigitNum(num++,n); for(int idx=0;idx&lt;nDigitString.length();idx++) { if(curT == p) { answerStrBuild.append(nDigitString.charAt(idx)); countT++; if(countT == t) { return answerStrBuild.toString(); } } curT++; if(curT &gt; m) { curT = 1; } } } }} 메모문제를 잘못 이해해서 이전에 밟은 땅은 다시 안밟는다고 해석했는데 그럼 문제에 모순이 생기는데 어쨌건 해보자 해서 백트래킹으로 풀려고 했었던 기억이 남 문제에 모순이 생긴다 -&gt; 문제를 잘못 이해한 것이므로 그냥 대충 넘어가면 안될 것 같다!","link":"/2021/07/14/2021-07/p12913/"},{"title":"프로그래머스 2레벨 12924 숫자의 표현 (브루트포스)","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12924 Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다. 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15 자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요. 풀이브루트포스 방식으로 품 i부터 n까지의 수를 선택했을 때 연속된 자연수를 선택한 모든 경우의 수로 조건에 맞으면 answer값을 증가시키면 풀리는 문제 코드12345678910111213141516171819202122232425262728class Solution { public int solution(int n) { int answer = 0; for(int i=1;i&lt;=n;i++) { int tmp = 0; for(int j=i;j&lt;=n;j++) { tmp+=j; if(tmp &gt; n) { break; } if(tmp == n) { answer++; break; } } } return answer; }} 메모어렵지 않은 문제였음","link":"/2021/07/15/2021-07/p12924/"},{"title":"프로그래머스 2레벨 12393 최대값과 최솟값","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12939 문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 “(최소값) (최대값)”형태의 문자열을 반환하는 함수, solution을 완성하세요.예를들어 s가 “1 2 3 4”라면 “1 4”를 리턴하고, “-1 -2 -3 -4”라면 “-4 -1”을 리턴하면 됩니다. 풀이각 값에 대해 최솟값과 최대값을 갱신해줌 코드123456789101112131415161718class Solution { public String solution(String s) { String[] strArray = s.split(&quot; &quot;); int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; int tmp = 0; for(int i=0;i&lt;strArray.length;i++) { tmp = Integer.parseInt(strArray[i]); min = Math.min(min,tmp); max = Math.max(max,tmp); } String answer = Integer.toString(min) + &quot; &quot; + Integer.toString(max); return answer; }} 메모어렵지 않은 문제였음","link":"/2021/07/15/2021-07/p12939/"},{"title":"프로그래머스 2레벨 12941 최솟값 만들기","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12941 길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다.배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.) 예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면 A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5) A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21) A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29) 즉, 이 경우가 최소가 되므로 29를 return 합니다. 배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요. 풀이단순히 정렬 알고리즘을 써서 각 배열을 곱하여 풀 수 있음 merge sort나 quick sort를 오랜만에 구현해볼까도 생각했지만 뭔가 귀찮아져서 생략 🙃 코드12345678910111213141516171819202122232425262728class Solution { public int solution(int n) { int answer = 0; for(int i=1;i&lt;=n;i++) { int tmp = 0; for(int j=i;j&lt;=n;j++) { tmp+=j; if(tmp &gt; n) { break; } if(tmp == n) { answer++; break; } } } return answer; }} 메모어렵지 않은 문제였음","link":"/2021/07/15/2021-07/p12941/"},{"title":"프로그래머스 2레벨 12945 피보나치수(메모라이제이션)","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12945 피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다. 예를들어 F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 와 같이 이어집니다. 2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요. 풀이오랜만에 다시 푼 피보나치 문제 n이 100000이하일 수 있는데 일반적인 피보나치로는 끝이나지 않아 통과하지 못할 것 따라서 메모라이제이션 기법을 써서 풀어야함 n이 크면 계산된 수가 커질 수 있는데 문제에서 나누라고한 값으로 나눈 나머지를 저장해주면 됨 코드1234567891011121314151617181920212223242526272829303132333435363738import java.util.Arrays;class Solution { int MAX = 100000+1; int dp[] = new int[MAX]; int divNum = 1234567; int fibo(int n) { if(n == 0) { return 0; } if(n == 1) { return 1; } if(dp[n-1]== -1) { dp[n-1] = fibo(n-1) % divNum; } if(dp[n-2] == -1) { dp[n-2] = fibo(n-2) % divNum; } return (dp[n-2] + dp[n-1]) % divNum; } public int solution(int n) { int answer = 0; Arrays.fill(dp, -1); answer = fibo(n); return answer; }} 메모어렵지 않은 문제였음","link":"/2021/07/15/2021-07/p12945/"},{"title":"프로그래머스 2레벨 12949 행렬의 곱셈","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12949 2차원 행렬 arr1과 arr2를 입력받아, arr1에 arr2를 곱한 결과를 반환하는 함수, solution을 완성해주세요. 풀이문제 설명만큼 간단한 쉬운 문제 그런데..왠지 못 풀겠다 어이어이 이 녀석 바보아니냐고..  행렬 계산을 알고 있으면 풀 수 있는 문제 반복문 조건에 계산되는 요소가 영향받는 게 무엇인가 생각해야함(행렬의 열에 영향받느냐 행에 영향받느냐 등) 코드12345678910111213141516171819202122232425262728class Solution{ int[][] solution(int[][] arr1, int[][] arr2) { int maxRow = Math.max( arr1.length, arr2.length); int maxCal = Math.max( arr1[0].length,arr2[0].length); int[][] answer = new int[arr1.length][arr2[0].length]; int result = 0; for(int i=0;i&lt;arr1.length;i++) { for(int j=0;j&lt;arr2[0].length;j++) { result = 0; for(int k=0;k&lt;arr1[0].length;k++) { result += arr1[i][k] * arr2[k][j]; } answer[i][j] = result; } } return answer; } } 메모문제 자체는 간단한 문제 그러나 능지 이슈로 풀지 못함 스스로 풀었는가 : ❎","link":"/2021/07/15/2021-07/p12949/"},{"title":"프로그래머스 2레벨 12951 JadenCase","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12951 JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요. 풀이언어에서 지원하는 메소드를 쓰거나 아스키코드로 처리하면 쉽게 풀 수 있는 문제 문제에서 나온 JadenCase를 그대로 만들어주면 됨 코드1234567891011121314151617181920212223242526272829303132class Solution { public String solution(String s) { char[] charArr = s.toCharArray(); boolean prevBlank = true; StringBuilder answer = new StringBuilder(); for(int i=0;i&lt;charArr.length;i++) { if(charArr[i] == ' ') { answer.append(' '); prevBlank = true; } else { if(prevBlank) { prevBlank = false; charArr[i] = Character.toUpperCase(charArr[i]); } else { charArr[i] = Character.toLowerCase(charArr[i]); } answer.append(charArr[i]); } } return answer.toString(); }} 메모StringBuffer -&gt; 기본적으로 주어진 크기가 적음 StringBuilder -&gt; 기본적으로 주어진 크기가 큼 문자열 크기가 상관없다면 StringBuilder 사용할 것","link":"/2021/07/15/2021-07/p12951/"},{"title":"프로그래머스 2레벨 12953 N개의 최소공배수 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/12953 두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요. 풀이문제 그대로 최소공배수를 구하는 문제 gcd는 유클리드 호제법이라는 방법을 사용했고 두 수의 최소공배수는 두 수의 곱을 두 수의 최대공약수로 나누면 된다. 만약 모른다고 하여도 금방 찾아보면 쉽게 이해할 수 있을 것임! ✍ 코드12345678910111213141516171819202122232425262728293031323334353637class Solution { static int gcd(int numA,int numB) { int result = 0; if(numA % numB == 0) { return numB; } else { result = gcd(numB,numA % numB); } return result; } static int lcd(int numA, int numB) { int result = 0; int gcd = 0; gcd = gcd(numA,numB); return (numA * numB)/gcd; } public int solution(int[] arr) { int answer = 0; int numA = arr[0]; for(int i = 1;i&lt;arr.length;i++) { numA = lcd(numA,arr[i]); } answer = numA; return answer; }} 메모스스로 풀었는가 : ✅","link":"/2021/07/15/2021-07/p12953/"},{"title":"programmers 17687 [3차] n진수 게임","text":"문제N진수 게임튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다. 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.이렇게 게임을 진행할 경우,0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …순으로 숫자를 말하면 된다. 한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …순으로 숫자를 말하면 된다. 이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라. 풀이 입력받은 10진수를 n진수로 변환한다. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution { public String getNDigitNum(int n,int digit) { StringBuilder sb = new StringBuilder(); int curNumber = n; if(curNumber == 0) { return &quot;0&quot;; } while(curNumber &gt; 0) { if(curNumber % digit &lt; 10) { sb.append(curNumber % digit); } else { sb.append((char)(curNumber % digit - 10 + 'A')); } curNumber /= digit; } return sb.reverse().toString(); } //0, 1, 1, 0, 1, 1, 1, 0, 0 //digit,number,people,count public String solution(int n, int t, int m, int p) { String nDigitString; StringBuilder answerStrBuild = new StringBuilder(); int curT = 1; int num=0; int countT = 0; while(true) { nDigitString = getNDigitNum(num++,n); for(int idx=0;idx&lt;nDigitString.length();idx++) { if(curT == p) { answerStrBuild.append(nDigitString.charAt(idx)); countT++; if(countT == t) { return answerStrBuild.toString(); } } curT++; if(curT &gt; m) { curT = 1; } } } }} 10진수 -&gt; n진수 변환m진수 -&gt; n진수 변환이 아닌 10진수 - &gt; n진수 변환인 점 유의 1234567891011121314151617181920212223public String getNDigitNum(int n,int digit){ StringBuilder sb = new StringBuilder(); int curNumber = n; if(curNumber == 0) { return &quot;0&quot;; } while(curNumber &gt; 0) { if(curNumber % digit &lt; 10) { sb.append(curNumber % digit); } else { sb.append((char)(curNumber % digit - 10 + 'A')); } curNumber /= digit; } return sb.reverse().toString();} n진수 변환 -&gt; 10진수 변환12345678910111213141516171819202122public static int nToTenDigit(String num, int N){ char[] numArray = num.toCharArray(); int ans = 0; for(int i=0;i &lt; numArray.length;i++) { if(numArray[i] &gt;= 'A') { //10진수 이상의 진수 ans = ans * N + (numArray[i] - 'A' + 10); } else { //10진수 미만의 n ans = ans * N + (numArray[i] - '0'); } }} 메모내가 직접 생각해서 구현한 방식은 비효율적이어서 인터넷에서 코드를 참조했다.","link":"/2021/07/06/2021-07/p17687/"},{"title":"프로그래머스 2레벨 42578 위장 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/42578 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다. 풀이문제 주제도 해시이고 문제를 읽어보면 뭔가 자바 HashMap을 사용하면 될 것 같은 문제 처음 생각하기로는 map을 String,String으로 만들어 중복된 옷을 제외하고 일일이 숫자를 세는 방식을 생각했는데 그것보다는 map을 String,int로 만들어 애초에 각 옷의 종류(key)에 몇가지의 옷 종류가 있는지를 계산하면 더욱 우아하게 풀 수 있음  코드123456789101112131415161718192021import java.util.HashMap;import java.util.Map.Entry;class Solution { public static int solution(String[][] clothes) { String key; HashMap &lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); for(int i=0;i&lt;clothes.length;i++) { key = clothes[i][1]; map.put(key, map.getOrDefault(key, 0)+1); } int answer = 1; for(Entry&lt;String,Integer&gt; entry : map.entrySet()) { answer *= entry.getValue() + 1; } return answer - 1; }} 메모스스로 풀었는가 : ❎","link":"/2021/07/15/2021-07/p42578/"},{"title":"프로그래머스 2레벨 42583 다리를 지나는 트럭 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/42583 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다. 예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 풀이문제에서 언제 다리에 올라가고 내리는지의 경계선을 주의해서 생각해야하는 문제 반복문 첫번째 if문반복문이 한 번 동작할때를 1초라고 생각하고 내리는 것을 우선했다 이 때 내리는 것은 다리를 건너기 위해서는 다리길이만큼의 초가 필요하다는 점을 유의하여 계산해주어야 한다. 반복문 두번째 if문다리의 무게가 버틸 수 있어 올릴 수 있다면 한 트럭을 올린다. 위 두 과정을 모두 건널 때 까지 반복한다. 이제보니 코드에 조건문을 너무 난발한 것 같다 중복되는 조건도 있고..  코드123456789101112131415161718192021222324252627282930313233343536import java.util.Queue;import java.util.LinkedList;class Solution{ //트럭이 몇대 올라갈 수 있느냐 static Queue&lt;Integer&gt; que = new LinkedList&lt;Integer&gt;(); public static int solution(int bridge_length, int weight, int[] truck_weights) { int curTime = 0; int curWeight = 0; int outIdx = 0; //2초 경과하면 그냥 나가 int i = 0; while(i != truck_weights.length || que.size() != 0) { if(que.size() != 0 &amp;&amp; ((curTime - que.peek()) &gt;= bridge_length)) { curWeight -= truck_weights[outIdx++]; que.poll(); } if(i != truck_weights.length &amp;&amp; curWeight + truck_weights[i] &lt;= weight) { que.add(curTime); curWeight += truck_weights[i]; i++; } curTime++; } return curTime; }} 메모스스로 풀었는가 : ✅","link":"/2021/07/15/2021-07/p42583/"},{"title":"프로그래머스 2레벨 42584 주식가격 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/42584 초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요. 풀이문제에서 스택을 쓰라고하니 스택을 쓰는 것 까지는 ok인데.. 분명 예전에 본 것 같은 문제인데도 풀이법이 잘 떠오르지 않았다..  찾아보니 스택에 다음 값을 담는다고 생각하면 이해가 됐다. 일단 가장 높은 주식 가격의 인덱스가 항상 스택의 top에 있다. 1stack.push(i); 만약 가장 높은 주식 가격이 붕괴됐다면 붕괴된 값은 빼주고 정답에 붕괴될 때까지 얼마나 걸렸는지 기록한다. 12345while( !(stack.empty()) &amp;&amp; prices[stack.peek()] &gt; prices[i]){ int tmp = stack.pop(); answer[tmp] = i - tmp;} 코드12345678910111213141516171819202122232425262728293031import java.util.Stack;class Solution { public int[] solution(int[] prices) { int[] answer = new int[prices.length]; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i=0;i&lt;prices.length;i++) { while( !(stack.empty()) &amp;&amp; prices[stack.peek()] &gt; prices[i]) { int tmp = stack.pop(); answer[tmp] = i - tmp; } stack.push(i); } while(!stack.empty()) { int tmp = stack.pop(); answer[tmp] = prices.length - 1 - tmp; } return answer; } } 메모스스로 풀었는가 : ❎ 뭔가 아이디어가 생각나지 않아 풀지 못한 문제.. 능지 어떡함!!!","link":"/2021/07/15/2021-07/p42584/"},{"title":"프로그래머스 2레벨 42747 H-Index JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/42747 H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 풀이단지 H-index의 개념이 잘 이해가 안돼서 조금 막힌 문제 거꾸로 정렬해서 가장 큰 논문이 인용된 수부터 현재 논문의 인용된 수보다 전체 몇 개 인용 됐는가 비교해서 전체 인용된 논문 수보다 큰 각 논문의 인용된 수가 몇개인지 찾는 문제 뭔가 국어문제같지만.. 문제에서 친절히 걸어준 링크를 참조하자 https://en.wikipedia.org/wiki/H-index 코드12345678910111213141516171819202122232425262728293031import java.util.Stack;class Solution { public int[] solution(int[] prices) { int[] answer = new int[prices.length]; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i=0;i&lt;prices.length;i++) { while( !(stack.empty()) &amp;&amp; prices[stack.peek()] &gt; prices[i]) { int tmp = stack.pop(); answer[tmp] = i - tmp; } stack.push(i); } while(!stack.empty()) { int tmp = stack.pop(); answer[tmp] = prices.length - 1 - tmp; } return answer; } } 메모스스로 풀었는가 : ❎ 국어 어질어질해서 포기..문제 이해력 부족!🙃","link":"/2021/07/15/2021-07/p42747/"},{"title":"프로그래머스 2레벨 42839 소수찾기 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/42839 한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 풀이단지 H-index의 개념이 잘 이해가 안돼서 조금 막힌 문제 거꾸로 정렬해서 가장 큰 논문이 인용된 수부터 현재 논문의 인용된 수보다 전체 몇 개 인용 됐는가 비교해서 전체 인용된 논문 수보다 큰 각 논문의 인용된 수가 몇개인지 찾는 문제 뭔가 국어문제같지만.. 문제에서 친절히 걸어준 링크를 참조하자 https://en.wikipedia.org/wiki/H-index 코드12345678910111213141516171819202122232425262728293031import java.util.Stack;class Solution { public int[] solution(int[] prices) { int[] answer = new int[prices.length]; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i=0;i&lt;prices.length;i++) { while( !(stack.empty()) &amp;&amp; prices[stack.peek()] &gt; prices[i]) { int tmp = stack.pop(); answer[tmp] = i - tmp; } stack.push(i); } while(!stack.empty()) { int tmp = stack.pop(); answer[tmp] = prices.length - 1 - tmp; } return answer; } } 메모스스로 풀었는가 : ❎ 국어 어질어질해서 못품…문제 이해력 부족!🙃","link":"/2021/07/15/2021-07/p42839/"},{"title":"프로그래머스 2레벨 42842 카펫 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/42842 Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다. Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요. 풀이브루트포스 방식으로 풀었다. 각 반복문에서 첫번째와 마지막 줄의 cal 즉 가로길이를 고정시키고 조건에 맞지 않으면 cal을 증가시켜 cal의 개수가 일치할 때까지 반복했다. 이는 가로길이에 의해 노란색이 결정되기 때문에 선택한 방식이다.✍ 코드12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solution { public int[] solution(int brown, int yellow) { int[] answer = new int[2]; int curRow = 1; int curCal = 3; while(true) { int tmpRow = 1; int tmpCal = curCal; int tmpBrown = 0; int tmpYellow = 0; while(true) { //첫줄이거나 yellow가 다 충족된 경우 마지막줄임 if(tmpRow == 1 || tmpYellow &gt;= yellow) { tmpBrown += curCal; if(tmpYellow &gt;= yellow) { break; } } else { tmpBrown+=2; tmpYellow += curCal - 2; } tmpRow++; } if(brown == tmpBrown &amp;&amp; tmpYellow == yellow) { answer[0] = tmpRow; answer[1] = curCal; break; } curCal++; } return answer; } } 메모스스로 풀었는가 : ✅","link":"/2021/07/15/2021-07/p42842/"},{"title":"프로그래머스 2레벨 42860 조이스틱 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/42860 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. 1234▲ - 다음 알파벳▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 “JAZ”를 만들 수 있습니다. 1234- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.따라서 11번 이동시켜 &quot;JAZ&quot;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 풀이문제 주제가 그리디문제여서 뭔가 그리디로 풀리는지 마음에 확 와닫지는 않았지만 그리디방식이라고 생각하고 관점을 고정해서 생각해서 풀긴 풀었다. 뭔가 잘못된 것 처럼 말하는 이유는 문제에 문제점이 제기된 부분이 있어서 인데 다음 글을 참고하기 바란다 https://velog.io/@hsw0194/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A1%B0%EC%9D%B4%EC%8A%A4%ED%8B%B1 요약하자면 커서를 이동하는데 있어서 왼쪽이나 오른쪽으로 이동할 수 있는데 만약 이동할 거리가 똑같다면 그리디로 풀었을 땐 아무곳에나 갈 수 있어야 하지만 예를들어 왼쪽을 선택했는데 오른쪽 선택한 것이 총 거리가 적은 경우 등 그리디로 풀었을 때 정답이 아닐 수 있다는 것이다. 이 문제에서는 이 경우 왼쪽을 선택했을 때를 정답으로 채택했다고 한다. 어쨌건 풀이는 각 커서의 알파벳은 초기에 A인 상태로 시작하는데 첫번째로 고려할 것목표 알파벳이 A라면 이미 끝난 것이고 그렇지 않으면 위 조이스틱을 움직여서 알파벳을 찾을지 아래 조이스틱을 움직여서 알파벳을 찾을지를 판단해야 하는데 둘 중 적게 이동할 수 있는 거리를 반환 getLessAlphaMove() 두 번째 고려할 것은오른쪽으로 커서를 이동했을 때, 왼쪽으로 커서를 이동했을 때 두가지 경우에 따라 뭐가 더 적은 거리인지 계산하면 된다. 이는 이미 목표알파벳이 아닌 위치를 찾는 것으로 오른쪽으로 갔을 때, 왼쪽으로 갔을 때 두 가지 경우의 수에 대해 적게 이동한 거리를 반환하면 된다. getLessCursorMove() 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import java.util.Arrays;class Solution{ static boolean visit[]; static int getLessAlphaMove(char curCh,char objCh) { //항상 curCh는 A 아니냐 int fromRight = 26; int objChIdx = objCh - 65; return Math.min(objChIdx,fromRight - objChIdx); } static int[] getLessCursorMove(int curIdx,char[] name,char[] result) { int resultIdx = 0; int rightMove = curIdx; int leftMove = curIdx; int amountLeftMove = 0; int amountRightMove = 0; int resultArr[] = new int[2]; while(result[leftMove] == name[leftMove]) { if(leftMove == 0) { leftMove = name.length; } leftMove--; amountLeftMove++; } resultArr[0] = leftMove; resultArr[1] = amountLeftMove; while(result[rightMove] == name[rightMove]) { if(rightMove == name.length-1) { rightMove = 0; } rightMove++; amountRightMove++; } if(amountRightMove &lt; Math.abs(amountLeftMove)) { resultArr[0] = rightMove; resultArr[1] = amountRightMove; } return resultArr; } static int solution(String name) { //a에서 obj로가느냐 //z에서 obj로 가느냐 //z에서 obj로 가느냐 int cursor = 0; int alphaMove = 0; int cursorMoveAmount = 0; int move = 0; char[] result = new char[name.length()]; for(int i=0;i&lt;result.length;i++) { result[i] = 'A'; } while(!Arrays.equals(result,name.toCharArray())) { if(name.charAt(cursor) != result[cursor]) { alphaMove = getLessAlphaMove('A',name.charAt(cursor)); result[cursor] = (name.toCharArray())[cursor]; } move+= alphaMove; if(Arrays.equals(result,name.toCharArray())) { break; } int tmp[] = getLessCursorMove(cursor, name.toCharArray(),result); cursor = tmp[0]; move+= tmp[1]; alphaMove = 0; for(int i=0;i&lt;result.length;i++) { //System.out.print(result[i]); } //System.out.println(); } int answer = move; return answer; } public static void main(String [] args) { //System.out.println(solution(&quot;JAZ&quot;)); }} 메모스스로 풀었는가 : ✅","link":"/2021/07/15/2021-07/p42860/"},{"title":"프로그래머스 2레벨 42885 구명보트 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/42885 무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 풀이뭔가 이 문제 쉬울 것이라 생각했는데 문제를 잘못 이해해서 약간 뻘짓했던 기억이 나는데 어떻게 잘 못 이해했는지는 기억이 안난다??  고멘 ㅎㅎ;(죄송합니다라는 뜻 ㅎㅎ;) 어쨌건 생각해보면 풀이는 단순히 한 번에 2명씩 밖에 못타지면 어쨌거나 가장 효율적으로 태우면 좋지않는가? 그럴려면 가장 무거운사람과 가장 가벼운 사람을 태우면 가장 효율적이라고 할 수 있겠다 (최대 2명이니까) 그래서 정렬해서 가장 무거운 사람을 마지막에 두고 가장 가벼운 사람을 앞에 두고 가능하다면 최대한 많이 태우고 그렇지 않으면 무거운 사람만 태우면 된다. ✍ 코드12345678910111213141516171819import java.util.Arrays;class Solution { public int solution(int[] people, int limit) { int answer = 0; Arrays.sort(people); int front = 0; int i = 0; for(i=people.length-1;i&gt;= front;i--) { if(limit &gt;= people[i] + people[front]) { front++; } answer++; } return answer; }} 메모스스로 풀었는가 : ❎","link":"/2021/07/15/2021-07/p42885/"},{"title":"프로그래머스 2레벨 77484 로또의 최고 순위와 최저 순위 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 로또 6/45(이하 ‘로또’로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다. 1 순위 당첨 내용 1 6개 번호가 모두 일치 2 5개 번호가 일치 3 4개 번호가 일치 4 3개 번호가 일치 5 2개 번호가 일치 6(낙첨) 그 외 로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.알아볼 수 없는 번호를 0으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 44, 1, 0, 0, 31 25라고 가정해보겠습니다. 당첨 번호 6개가 31, 10, 45, 1, 6, 19라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다. 당첨 번호 31 10 45 1 6 19 결과 최고 순위 번호 31 0→10 44 1 0→6 25 4개 번호 일치, 3등 최저 순위 번호 31 0→11 44 1 0→7 25 2개 번호 일치, 5등 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다. 알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다. 3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다. 알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다. 5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다. 민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요. 풀이최저와 최고 순위를 알고 싶은 것인데 보이지 않는 숫자가 있는 것이니까 최저 순위는 보이지 않는 숫자를 정답과 다른 것으로 하고 최고 순위는 보이지 않는 숫자를 정답과 동일한 것으로 하면 된다. 뭔가 문제는 길어보이지만? 간단히 생각하면 꽤 쉽게 풀리는 문제 ✅ 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { static boolean isThereAnswer(int[] win_nums,int val) { for(int i=0;i&lt;win_nums.length;i++) { if(win_nums[i] == val) { return true; } } return false; } public int[] solution(int[] lottos, int[] win_nums) { int[] answer = new int[2]; int maxWinRate = 7; int minWinRate = 7; int zeroCount = 0; for(int i=0;i&lt;6;i++) { if(lottos[i] == 0) { maxWinRate--; } else { if(isThereAnswer(win_nums,lottos[i])) { maxWinRate--; minWinRate--; } } } if(maxWinRate &gt;= 6) { maxWinRate = 6; } if(minWinRate &gt;= 6) { minWinRate = 6; } answer[0] = maxWinRate; answer[1] = minWinRate; return answer; }} 메모스스로 풀었는가 : ✅","link":"/2021/07/15/2021-07/p77484/"},{"title":"프로그래머스 2레벨 77485 행렬 테두리 회전하기 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/77485 rows x columns 크기인 행렬이 있습니다. 행렬에는 1부터 rows x columns까지의 숫자가 한 줄씩 순서대로 적혀있습니다. 이 행렬에서 직사각형 모양의 범위를 여러 번 선택해, 테두리 부분에 있는 숫자들을 시계방향으로 회전시키려 합니다. 각 회전은 (x1, y1, x2, y2)인 정수 4개로 표현하며, 그 의미는 다음과 같습니다. x1 행 y1 열부터 x2 행 y2 열까지의 영역에 해당하는 직사각형에서 테두리에 있는 숫자들을 한 칸씩 시계방향으로 회전합니다. 다음은 6 x 6 크기 행렬의 예시입니다. 이 행렬에 (2, 2, 5, 4) 회전을 적용하면, 아래 그림과 같이 2행 2열부터 5행 4열까지 영역의 테두리가 시계방향으로 회전합니다. 이때, 중앙의 15와 21이 있는 영역은 회전하지 않는 것을 주의하세요. 행렬의 세로 길이(행 개수) rows, 가로 길이(열 개수) columns, 그리고 회전들의 목록 queries가 주어질 때, 각 회전들을 배열에 적용한 뒤, 그 회전에 의해 위치가 바뀐 숫자들 중 가장 작은 숫자들을 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요. 풀이구현력 문제임 시키는대로 하면 됨 라고할뻔 ㅎㅎ; 이차원배열을 조금 다뤄야하는 문제임 각 방향으로 값을 밀어야하는데 중요한 것은 시작에 있는 값을 저장할 것인지 마지막에 있는 값을 저장할 것인지 선택해서 저장한 뒤에 맨 마지막에 저장한 값으로 백업해주어야함 이게 무슨말이냐면 변수 두개의 값을 바꿀려면 tmp변수가 필요하듯이 위 문제에서도 밀리는 부분에 대한 임시 저장을 해주어야한다는 말임 너무 당연한거 아닌가 싶을 수 있는데 당연한거 맞고 뭔가라도 써야할 것 같아서 ㅎㅎ; ✍ 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution { static int[][] getInput(int rows,int columns) { int count = 1; int arr[][] = new int[rows+1][columns+1]; for(int i=1;i&lt;=rows;i++) { for(int j=1;j&lt;=columns;j++) { arr[i][j] = count++; } } return arr; } public int[] solution(int rows, int columns, int[][] queries) { int[] answer = new int[queries.length]; int startRow,startCal,endRow,endCal; int arr[][] = getInput(rows,columns); for(int i=0;i&lt;queries.length;i++) { startRow = queries[i][0]; startCal = queries[i][1]; endRow = queries[i][2]; endCal = queries[i][3]; //오른쪽으로 int curCal,curRow = 0; int tmp = 0; int prev = arr[startRow][startCal]; int min = 987654321; for(curCal = startCal; curCal&lt;=endCal-1;curCal++) { min = Math.min(min,prev); tmp = arr[startRow][curCal+1]; arr[startRow][curCal+1] = prev; prev = tmp; } //시작 row에서 맨 마지막칸 이전값 저장됨 for(curRow = startRow; curRow&lt;=endRow-1;curRow++) { min = Math.min(min,prev); tmp = arr[curRow+1][curCal]; arr[curRow+1][curCal] = prev; prev = tmp; } for(;curCal&gt;=startCal+1;curCal--) { min = Math.min(min,prev); tmp = arr[curRow][curCal-1]; arr[curRow][curCal-1] = prev; prev = tmp; } for(;curRow&gt;=startRow+1;curRow--) { min = Math.min(min,prev); tmp = arr[curRow-1][curCal]; arr[curRow-1][curCal] = prev; prev = tmp; } answer[i] = min; } return answer; }} 메모스스로 풀었는가 : ✅","link":"/2021/07/15/2021-07/p77485/"},{"title":"프로그래머스 2레벨 77486 다단계 칫솔 판매 JAVA","text":"문제링크 : https://programmers.co.kr/learn/courses/30/lessons/77486 민호는 다단계 조직을 이용하여 칫솔을 판매하고 있습니다. 판매원이 칫솔을 판매하면 그 이익이 피라미드 조직을 타고 조금씩 분배되는 형태의 판매망입니다. 어느정도 판매가 이루어진 후, 조직을 운영하던 민호는 조직 내 누가 얼마만큼의 이득을 가져갔는지가 궁금해졌습니다. 예를 들어, 민호가 운영하고 있는 다단계 칫솔 판매 조직이 아래 그림과 같다고 합시다. 민호는 center이며, 파란색 네모는 여덟 명의 판매원을 표시한 것입니다. 각각은 자신을 조직에 참여시킨 추천인에 연결되어 피라미드 식의 구조를 이루고 있습니다. 조직의 이익 분배 규칙은 간단합니다. 모든 판매원은 칫솔의 판매에 의하여 발생하는 이익에서 10% 를 계산하여 자신을 조직에 참여시킨 추천인에게 배분하고 나머지는 자신이 가집니다. 모든 판매원은 자신이 칫솔 판매에서 발생한 이익 뿐만 아니라, 자신이 조직에 추천하여 가입시킨 판매원에게서 발생하는 이익의 10% 까지 자신에 이익이 됩니다. 자신에게 발생하는 이익 또한 마찬가지의 규칙으로 자신의 추천인에게 분배됩니다. 단, 10% 를 계산할 때에는 원 단위에서 절사하며, 10%를 계산한 금액이 1 원 미만인 경우에는 이득을 분배하지 않고 자신이 모두 가집니다. 예를 들어, 아래와 같은 판매 기록이 있다고 가정하겠습니다. 칫솔의 판매에서 발생하는 이익은 개당 100 원으로 정해져 있습니다. 판매원 판매 수량 이익금 young 12 1,200 원 john 4 400 원 tod 2 200 원 emily 5 500 원 mary 10 1,000 원 판매원 young 에 의하여 1,200 원의 이익이 발생했습니다. young 은 이 중 10% 에 해당하는 120 원을, 자신을 조직에 참여시킨 추천인인 edward 에게 배분하고 자신은 나머지인 1,080 원을 가집니다. edward 는 young 에게서 받은 120 원 중 10% 인 12 원을 mary 에게 배분하고 자신은 나머지인 108 원을 가집니다. 12 원을 edward 로부터 받은 mary 는 10% 인 1 원을 센터에 (즉, 민호에게) 배분하고 자신은 나머지인 11 원을 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 그 후, 판매원 john 에 의하여 400 원의 이익이 발생합니다. john 은 10% 인 40 원을 센터에 배분하고 자신이 나머지인 360 원을 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 또 그 후에는 판매원 tod 에 의하여 200 원 이익이 발생하는데, tod 자신이 180 원을, 추천인인 jaimie 가 그 중 10% 인 20 원을 받아서 18 원을 가지고, jaimie 의 추천인인 mary 는 2 원을 받지만 이것의 10% 는 원 단위에서 절사하면 배분할 금액이 없기 때문에 mary 는 2 원을 모두 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 그 다음으로 emily 가 칫솔 판매를 통하여 얻은 이익 500 원은 마찬가지의 규칙에 따라 emily 에게 450 원, mary 에게 45 원, 그리고 센터에 5 원으로 분배됩니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 마지막으로, 판매원 mary 는 1,000 원의 이익을 달성하고, 이 중 10% 인 100 원을 센터에 배분한 후 그 나머지인 900 원을 자신이 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 위와 같이 하여 모든 조직 구성원들의 이익 달성 현황 집계가 끝났습니다. 지금까지 얻은 이익을 모두 합한 결과를 그림으로 나타내면 아래와 같습니다. 이 결과가 민호가 파악하고자 하는 이익 배분 현황입니다. 각 판매원의 이름을 담은 배열 enroll, 각 판매원을 다단계 조직에 참여시킨 다른 판매원의 이름을 담은 배열 referral, 판매량 집계 데이터의 판매원 이름을 나열한 배열 seller, 판매량 집계 데이터의 판매 수량을 나열한 배열 amount가 매개변수로 주어질 때, 각 판매원이 득한 이익금을 나열한 배열을 return 하도록 solution 함수를 완성해주세요. 판매원에게 배분된 이익금의 총합을 계산하여(정수형으로), 입력으로 주어진 enroll에 이름이 포함된 순서에 따라 나열하면 됩니다. 풀이약간 구현력문제라는 생각을 한 문제 각 seller에 대해서 문제에서 주어진 것처럼 수익을 배분하는데 이것은 재귀로 구현하였다. 각 seller를 추천한 추천인에 대해서는 enrollIdxMapMap이 누가 누구를 추천했는지 담도록 하였다. 수익을 분배하는 조건 그리고 얼마나 분배할지가 관건인 문제 그리고 seller와 enroll을 어떻게 묶을지를 조금 생각해주어야 하는데 이러한 기반을 쌓고 나면 풀 수 있는 문제🙃 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.HashMap;import java.util.Set;class Solution{ static int ans[]; static HashMap&lt;String,Integer&gt; enrollIdxMap = new HashMap&lt;String,Integer&gt;(); static boolean isDivideAble(int money) { if(money / 10 &gt;= 1) { return true; } return false; } static void divideToRefer(String curSeller, int curMoney,String[] enroll,String[] referral) { //System.out.println(curSeller + &quot;, &quot; + curMoney + &quot; ing&quot;); int enrollIdx = getIdxFromEnroll(curSeller); if(enrollIdx == -1) { //System.out.println(curSeller); return; } if(curMoney / 10 &lt; 1) { //System.out.println(curMoney + &quot; add&quot;); ans[enrollIdx] += curMoney; } else { ans[enrollIdx] += curMoney - curMoney / 10; //System.out.println((curMoney - curMoney / 10) + &quot; add&quot;); divideToRefer(referral[enrollIdx],curMoney / 10,enroll,referral); } } static int getIdxFromEnroll(String curSellerString) { return enrollIdxMap.get(curSellerString); } static void setEnrollIdxMap(String[] enroll) { for(int i=0;i&lt;enroll.length;i++) { enrollIdxMap.put(enroll[i],i); } enrollIdxMap.put(&quot;-&quot;,-1); } public int[] solution(String[] enroll, String[] referral, String[] seller, int[] amount) { //각 enroll이 받은 수익금 int[] answer = new int[enroll.length]; ans = new int[enroll.length]; setEnrollIdxMap(enroll); for(int i=0;i&lt;seller.length;i++) { int curMoney = amount[i] * 100; divideToRefer(seller[i], curMoney, enroll, referral); } answer = ans; return answer; }} 메모스스로 풀었는가 : ✅","link":"/2021/07/15/2021-07/p77486/"},{"title":"Pet-Project-web-아이피-로그인 기능","text":"개요게시글에 아이피를 추가하고 관련 기능을 추가함 기능아이피 관련 아이피를 추가하는 것은 다음 이유가 있다. 추천, 비추천 기능에 있어서 중복을 막기 위함 비로그인 유저,로그인 유저를 구분하기 위함user(ip) &lt;- 비로그인 유저user &lt;- 로그인 유저 로그인한 유저의 경우에는 로그인 정보로 구분을 하는데 비로그인 유저의 글은 ip로 구분하는 것은 또 아니다. 밖에서 글을 작성하고 집에와서 글을 수정하거나 삭제하는 것이 가능해야 한다고 생각했기 때문이다. 로그인 관련 로그인 기능을 추가함으로써 변경되는 사항들 댓글 작성 로그인 유무에 따라 삭제 대댓글 작성 로그인 유무에 따라 삭제 글쓰기 로그인 유무에 따라 수정, 삭제 예시 그림 [비로그인 유저인 경우 ip를 출력하는 모습] [로그인 유무에 따라 ip가 출력되고 안출력되는 모습] 코드ip 관련 사용자의 ip 가져오기 12345def get_covered_ip(): ip = socket.gethostbyname(socket.gethostname()) front_ip = ip.split('.')[0] back_ip = ip.split('.')[1] return front_ip + '.' + back_ip 위 코드를 실행하면 ip에 123.456.789.876~ 같은 형식으로 ip가 출력된다. 실제로 보여주는 ip 형식은 123.456 형식을 원하기 때문에 split(‘.’)을 이용하여 일부를 제거했다. 로그인 관련 로그인 구현 1234567891011121314151617181920212223242526272829303132@login_bp.route('/login/&lt;string:before_page&gt;',methods=['GET','POST'])def login(before_page=None): form = UserLoginForm() if request.method == 'POST' and form.validate_on_submit(): error = None db = Database() user = db.executeAll(&quot;SELECT id,password FROM user WHERE id = '%s'&quot; % (form.username.data)) if len(user) == 0: user = 0 else: password = user[0]['password'] user = user[0]['id'] if user == 0: error = &quot;존재하지 않는 사용자입니다&quot; elif not password == form.password.data: error = &quot;비밀번호가 올바르지 않습니다.&quot; if error is None: session.clear() session['user_id'] = user print(&quot;이전 페이지:&quot;,before_page) if before_page == 'checklist': return redirect(url_for(before_page+'.checklist')) elif before_page != None: return redirect(url_for(before_page+'.list')) return redirect(url_for('main.index')) flash(error) return render_template('/main/login.html',form=form) 우선 login 페이지(html)에서 post 형태로 통신이 들어오면, 입력된 form이 login form 규격에 맞는지 체크한다. 맞다면 데이터베이스에서 로그인 정보를 가져온다. 실제로 로그인 정보가 일치하면 세션에 로그인 정보를 갱신하게 된다. 로그인 유무 확인 123456789101112@login_bp.before_app_requestdef load_logged_in_user(): user_id = session.get('user_id') if user_id is None: g.user = None g.idx = None else: db = Database() g.user = db.executeOne(&quot;SELECT id,idx FROM user WHERE id = '%s' &quot; % (user_id)) g.idx = g.user['idx'] g.user = g.user['id'] 위 코드에서 before_app_request는 이름 그대로 어떤 request를 하기 전에 항상 거치는 메소드를 명시하는 것이다. 앞서 본 코드에서 로그인을 하게되면 session에 값이 갱신되고 로그인 한 후에는 항상 load_logged_in_uer() 메소드를 거쳐 g(플라스크의 전역변수 정도로 이해)의 전역변수를 지정해주는 식으로 로그인을 구분짓을 수 있다. 장고 템플릿에서의 예 123456789101112131415161718{% if g.user %} Hello {{g.user}}&lt;br&gt; &lt;ul class=&quot;login&quot;&gt; &lt;li&gt;&lt;a href=&quot;/logout&quot; style=&quot;margin-bottom:10px;&quot; class=&quot;button big&quot;&gt;Logout&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; {% else %} &lt;div class=&quot;btns&quot;&gt; &lt;div class=&quot;loginArea&quot;&gt; &lt;li&gt; {% if request.path != &quot;/login&quot; %} &lt;a href=&quot;/login&quot; class=&quot;button big&quot; style=&quot;margin-right:10px;&quot;&gt; &lt;span style = &quot; color:white;&quot;&gt; Login &lt;/span&gt; &lt;/a&gt; {% endif %} 중요한것은 {{g.user}}로 로그인을 구분지어 이에따라 보여지는 html을 수정할 수 있다는 점이다. 위는 다음과 같이 출력된다. 백엔드 상 예제 1234567if loginUser == 1 and (username==session.get('user_id')): content_title = data[0]['board_content_title'] content_text = data[0]['board_content'] username = data[0]['write_user_name'] password = &quot;****&quot; ...이하 생략 위 코드는 수정버튼을 눌렀을 때를 생각해보면 로그인한 유저 = 게시글을 작성하는 유저를 확인하는 부분이다 조건문의 username은 앞서 데이터베이스에서 해당 게시글을 작성한 유저를 의미하고 session.get(‘user_id’)를 통해 현재 로그인한 유저와 비교한다. 참고로 loginUser는 게시글을 작성한 유저의 로그인 유무를 의미하는 변수이다. 이로써 게시판에 로그인,ip 기능을 적용했다.아무래도 플라스크를 이용하여 웹 페이지를 구현하면 html이라던가 form이라던가 세부적인 사항도 많이 남아 있지만 전체 코드를 담기에는 의미없는 반복, 세부사항이 너무 많아 생략한다는 점 양해 바란다.","link":"/2021/07/02/2021-07/web-add-clone-ip-login-discrption/"},{"title":"Graph B2667","text":"개요백준 문제 2667번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 약 4시간 https://www.acmicpc.net/problem/2667 문제&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다.1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다.철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다.여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다.대각선상에 집이 있는 경우는 연결된 것이 아니다.&lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다.지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오. 입력첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다. 출력첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오. 예제 입력170110100011010111101010000111010000001111100111000 예제 출력 13789 계획한 풀이법우선 입력에 따라 그래프를 제대로 구성했다면, BFS나 DFS를 사용하면 단지를 쉽게 찾을 수 있다.이 중에서 나는 BFS를 사용했다. 그래프 연결그래프 연결에 이차원 배열을 사용하지 않았다 왜냐하면 입력 한개를 row 하나라고 생각했을 때,나는 인덱스를 사용하고 싶었는데 이차원 배열을 사용하면 상하 row와 연결이 쉽지 않다고 생각했기 때문이다.위 예제의01101000110101을 보면 각 입력의 011부분이 연결돼야 하는데 row[0][1] -&gt; row[1][1]연결이 쉽지 않다고 생각해서 이다. (삼차원 벡터를 사용하면 가능하지도?) 오래걸렸던 이유문제 자체는 쉬웠고 접근법도 빠르게 떠올랐으며 정답에 가까웠다.문제는 위 입력을 구현하는 것이 첫번째 고비였다.두번째는 문제를 잘 못 이해해서 시간이 오래 걸렸는데이것은 게시판을 둘러보면서 문제를 잘 못 이해했다는 것을 발견했다.집 한채만 있을 때는 단지가 아니라서 생각해서 출력을 하지 않도록 했는데집 한채도 단지라고 판정짓고 출력해야 했던 것이다.이 경우에는 자기자신을 가르키게 해서 사이클을 형성했고 이 경우 자기자신만 자신을 가르키기 때문에해당 정점의 연결이 몇개 돼 있는지 보고 한 개라면 이 경우인 것을 이용했다.(다른 정점과 연결이 되면 무조건 연결이 2개 이상이다)그 두가지를 해결하니 문제도 해결됐다. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int MAX = 1001;struct{ int num;}void Graph::connectEdge(int v,int e){ graph[v].push_back(e); if(v == e) { return; } graph[e].push_back(v);}void Graph:: BFS(int startV){ queue&lt;int&gt; que; que.push(startV); int curV = 0; int notVisited = 1; int houseCount = 1; visit[startV] = true; if(graph[startV].size() == 1) { houseSet.push_back(houseCount); return; } while(que.size()!=0) { curV = que.front(); que.pop(); ////cout &lt;&lt; &quot;현재 정점 : &quot; &lt;&lt; curV &lt;&lt; &quot;\\n&quot;; for(int i=0;i&lt;graph[curV].size();i++) { if(visit[graph[curV][i]] == 1) { continue; } notVisited = 0; que.push(graph[curV][i]); visit[graph[curV][i]] = true; houseCount++; } } if(!notVisited) { houseSet.push_back(houseCount); //doSomeThing(); }}void solve(){ int n = 0; cin &gt;&gt; n; Graph g = Graph(); fill_n(g.visit,MAX,0); int maxSize = n*n; int num[maxSize]; for(int i=0;i&lt;maxSize;i++) { vector&lt;int&gt; nodeTmp; g.graph.push_back(nodeTmp); } int idx = 0; for(int row = 0;row &lt; n;row++) { char input[n]; char prevRow[n]; for(int cal = 0;cal&lt;n;cal++,idx++) { cin &gt;&gt; input[cal]; if(input[cal] - '0') { if(cal == 0) { g.connectEdge(idx,idx); } else if(input[cal-1] - '0') { g.connectEdge(idx,idx-1); } else { g.connectEdge(idx,idx); } } if(row != 0) { if(prevRow[cal] - '0' &amp;&amp; input[cal] - '0') { g.connectEdge(idx - n,idx); } } } for(int i=0;i&lt;n;i++) { prevRow[i] = input[i]; } } for(int i=0;i&lt;maxSize;i++) { if(g.visit[i]) { continue; } g.BFS(i); } cout &lt;&lt; g.houseSet.size() &lt;&lt;&quot;\\n&quot;; sort(g.houseSet.begin(),g.houseSet.end()); if(g.houseSet.size() == 0) { cout &lt;&lt; &quot;0&quot;; } for(int i=0;i&lt;g.houseSet.size();i++) { cout &lt;&lt; g.houseSet[i] &lt;&lt; &quot;\\n&quot;; }}int main(){ solve();}","link":"/2021/08/01/2021-prev/0308_graph_b2667/"},{"title":"Graph B4963","text":"개요백준 문제 2667번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 약 5시간https://www.acmicpc.net/problem/4963 문제정사각형으로 이루어져 있는 섬과 바다 지도가 주어진다. 섬의 개수를 세는 프로그램을 작성하시오. 한 정사각형과 가로, 세로 또는 대각선으로 연결되어 있는 사각형은 걸어갈 수 있는 사각형이다. 두 정사각형이 같은 섬에 있으려면, 한 정사각형에서 다른 정사각형으로 걸어서 갈 수 있는 경로가 있어야 한다. 지도는 바다로 둘러싸여 있으며, 지도 밖으로 나갈 수 없다. 입력입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 지도의 너비 w와 높이 h가 주어진다. w와 h는 50보다 작거나 같은 양의 정수이다. 둘째 줄부터 h개 줄에는 지도가 주어진다. 1은 땅, 0은 바다이다. 입력의 마지막 줄에는 0이 두 개 주어진다. 출력각 테스트 케이스에 대해서, 섬의 개수를 출력한다. 123456789101112131415161718192021222324252627예제 입력 1 1 102 20 11 03 21 1 11 1 15 41 0 1 0 01 0 0 0 01 0 1 0 11 0 0 1 05 41 1 1 0 11 0 1 0 11 0 1 0 11 0 1 1 15 51 0 1 0 10 0 0 0 01 0 1 0 10 0 0 0 01 0 1 0 10 0 12345678예제 출력 1011319 계획한 풀이법 그래프 연결(연결되지 않으면 자기자신만 연결) DFS로 개수 세기 그래프 연결이번에는 map이라는 2차원 배열과 벡터 2차원 배열을 사용했다.우선 입력 자체는 map에 우선 입력 후 벡터 2차원 배열(그래프 연결)에 edge들을 연결하는 식으로 구현했다.지금 생각해보니 map이 없어도 입력받은 값들의 이전 값들만 이용하여 연결 할 수 있을 것 같다. (왼쪽 배열 값과 위쪽 배열 값, 대각선 배열 값) 생각한 팁그래프를 연결할 때, 다른 edge와 연결이 되더라도 자신이 1이라면 자기 자신과의 사이클을 형성하는 것이 편하다.다른 edge와 연결이 안 된 경우와 자기 자신의 사이클을 형성하는 것을 분리해 버리면 예외처리가 너무 복잡해지는 것 같았다. 오래걸렸던 이유문제 자체는 해결 방법을 빠르게 생각했다.실제로 크게 어렵지 않은 문제이기도 하고 대부분 현한 그대로가 정답일 수 있다고 생각한다.우선 결론부터 짓으면 c++에 아직 익숙치 않아 속도가 나지 않는다고 생각한다.이것은 구현력이 부족하다고 할 수 있겠다.디버깅을 하면서 다음과 같은 문제가 있었다. 벡터를 초기화할 때 이전 테스트 케이스의 벡터 크기가 남아있음.(초기화 문제) 가로와 세로 크기를 입력 받은 뒤 둘을 서로 바꿔 생각함속도 향상을 위해서 한번에 꼼꼼하게 코딩하도록 하고 익숙치 않은 함수들에 익숙해 지려고 노력해야 겠다. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;const int MAX = 2500;vector&lt;vector&lt;int&gt;&gt; graph;int map[MAX][MAX];int visit[MAX];//전역변수 써서 코드 간결하게 짜보기void init(int row,int cal){ for(int i=0;i &lt; graph.size();i++) { graph[i].clear(); } graph.clear(); int maxIdx = row * cal; for(int i = 0;i&lt;row;i++) { for(int j= 0;j&lt;cal;j++) { cin &gt;&gt; map[i][j]; } } for(int i=0;i&lt;maxIdx;i++) { vector&lt;int&gt; tmp; graph.push_back(tmp); }}void connectEdge(int v,int e){ //////cout &lt;&lt; &quot;V와 E 연결\\n&quot;; //////cout &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; e &lt;&lt;&quot;\\n&quot;; graph[v].push_back(e); graph[e].push_back(v);}int DFS(int startV){ int onesCheck = 0; stack &lt;int&gt; s; s.push(startV); int curV = 0; //cout &lt;&lt; &quot;시작 정점 : &quot; &lt;&lt; startV &lt;&lt; &quot;\\n&quot;; while(s.size()!= 0) { curV = s.top(); //cout &lt;&lt; &quot;V : &quot; &lt;&lt; curV &lt;&lt; &quot;\\n&quot;; s.pop(); visit[curV] = true; //cout &lt;&lt; graph[curV].size() &lt;&lt; &quot;&lt;- 크기\\n&quot;; for(int i=0;i&lt;graph[curV].size();i++) { if(!visit[graph[curV][i]]) { s.push(graph[curV][i]); } onesCheck = 1; } } if(onesCheck) { return 1; } return 0;}void edgeConnect(int width,int height){ int idx = 0; int isLeftLand = 0; int isCurLand = 0; int isUpLand = 0; int isLeftDiagonalLand = 0; int isRightDiagonalLand = 0; for(int row = 0; row &lt; height; row++) { for(int cal = 0;cal &lt; width; cal++,idx++) { isCurLand = map[row][cal]; if(isCurLand) { //cout &lt;&lt; idx &lt;&lt; &quot;번째 연결 시도\\n&quot;; int isConnectedOnce = 0; if(cal-1 &gt;= 0) { //왼쪽 연결 isLeftLand = map[row][cal-1]; if(isLeftLand) { //cout &lt;&lt; &quot;왼쪽 연결\\n&quot;; connectEdge(idx,idx-1); isConnectedOnce = 1; } } if(row != 0) { //위 연결 isUpLand = map[row-1][cal]; if(isUpLand) { //cout &lt;&lt; &quot;위 연결\\n&quot;; connectEdge(idx,idx-width); isConnectedOnce = 1; } //왼쪽 대각선 연결 if(cal != 0) { isLeftDiagonalLand = map[row-1][cal-1]; if(isLeftDiagonalLand) { //cout &lt;&lt; &quot;왼쪽 위 대각선 연결\\n&quot;; connectEdge(idx,idx-1-width); isConnectedOnce = 1; } } //오른 대각선 연결 if(cal+1 != width) { isRightDiagonalLand = map[row-1][cal+1]; if(isRightDiagonalLand) { //cout &lt;&lt; &quot;오른 위 대각선 연결\\n&quot;; connectEdge(idx,idx+1-width); isConnectedOnce = 1; } } } if(!isConnectedOnce) { //cout &lt;&lt; &quot;자기자신 연결\\n&quot;; connectEdge(idx,idx); } } } }}void printAll(int height,int width){ //cout &lt;&lt; &quot;프린트 시작 : \\n&quot;; for(int row = 0;row&lt;height;row++) { for(int cal = 0; cal&lt;width;cal++) { //cout &lt;&lt; map[row][cal] &lt;&lt; &quot; &quot;; } //cout &lt;&lt; &quot;\\n&quot;; } //cout &lt;&lt; &quot;프린트 종료\\n&quot;;}void solve(){ int width = -1; int height = -1; int maxIdx = 0; int landCount = 0; int count = 0; while(1) { //cout &lt;&lt; ++count &lt;&lt; &quot;번째 테스트케이스\\n&quot;; landCount = 0; cin &gt;&gt; width &gt;&gt; height; //cout &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; &quot;\\n&quot;; maxIdx = width * height; if(width == 0 &amp;&amp; height == 0) { break; } fill_n(visit,MAX,0); fill(&amp;map[0][0],&amp;map[MAX-1][MAX],0); //벡터 해제 필요 init(height,width); if(width == 1 &amp;&amp; height == 1) { cout &lt;&lt; map[0][0] &lt;&lt; &quot;\\n&quot;; continue; } edgeConnect(width,height); for(int i = 0;i&lt;maxIdx;i++) { if(!visit[i]) { int result = 0; //cout &lt;&lt; i &lt;&lt; &quot;번째 DFS 시작\\n&quot;; result = DFS(i); if(result) { //cout &lt;&lt; i &lt;&lt; &quot;번째 DFS의 탐색 성공\\n&quot;; } landCount += result; } } cout &lt;&lt; landCount &lt;&lt; &quot;\\n&quot;; }}int main(){ solve();} 익숙해져야 할 함수 2차원 벡터 초기화 1234567891011121314151617 //아래의 코드로 구현해서 테스트 케이스마다 벡터가 제대로 초기화 되지 않음//MAX x MAX의 2차원 벡터 생성vector&lt;vector&lt;int&gt;&gt; graph(MAX, vector&lt;int&gt;(MAX));//앞의 두 인자는 어디부터 어디까지, 세번째 인자는 넣을 값//begin부터 end까지 각 row에 MAX만큼의 각 vector&lt;int&gt;를 0으로 초기화한다 fill(graph.begin(), graph.end(), vector&lt;int&gt;(MAX, 0));//테스트 케이스마다 아래의 코드로 초기화 해주어야 했음.for(int i=0;i &lt;graph.size();i++){ graph[i].clear();}graph.clear();``","link":"/2021/08/01/2021-prev/0309_graph_b4963/"},{"title":"Graph B7576","text":"개요백준 문제 7576번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 약 5시간https://www.acmicpc.net/problem/7576 문제철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다. 창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다. 토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다. 입력첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 토마토가 하나 이상 있는 경우만 입력으로 주어진다. 출력여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다. ​ 계획한 풀이법문제 해결을 위한 개괄적인 풀이방법은 단순하다. 익은 토마토라면 주변의 인접한 토마토를 보고 0이라면 그 토마토도 1로 바꾼다. 위 과정을 전체 토마트에 반복하며 날짜를 계산한다. 위 방법을 생각해보니 그래프가 필요한가? 싶어서 2차원 배열로 한번 풀어봤었다. 2차원 배열로 풀이하니 시간 초과가 발생했다. 오래걸렸던 이유 그래프 연결 구현을 너무 복잡하게 구현하려고 함. 복잡하기만 한 구현에 아무런 이점도 없는데도 그냥 고집으로 3차원 벡터를 사용할려고 함 BFS를 쓰지 않고 구현 BFS를 안쓰고 구현할 수 있지 않을까? 하는 생각에 고집부리면서 BFS 안쓸려고함 속도 개선 고집을 부리느라 문제를 많이 못품 문제 푼 수 = 경험 = 실력 1시간 반 이상 소요시간이 넘어가면 풀던 것도 멈추고 풀이 방식이 맞는지 찾아보도록 해야함 고집 부리지말고 가장 쉽고 빠르게 구현할 수 있는 방법을 사용하도록 하자 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int MAX = 1001;queue&lt;pair&lt;int,int&gt;&gt; q;int graph[MAX][MAX];int M = 0;int N = 0;bool leftCheck(int x,int y){ if(x != 0 &amp;&amp; graph[y][x-1] == 0) { return true; } return false;}bool rightCheck(int x,int y){ if(x != N-1 &amp;&amp; graph[y][x+1] == 0) { return true; } return false;}bool upCheck(int x,int y){ if(y!=0 &amp;&amp; graph[y-1][x] == 0) { return true; } return false;}bool downCheck(int x,int y){ if(y+1 != M &amp;&amp; graph[y+1][x] == 0) { return true; } return false;}void checkAndMark(int x,int y,int curDay){ //cout &lt;&lt; y+1 &lt;&lt; &quot; , &quot; &lt;&lt; x+1 &lt;&lt; &quot; : &quot; &lt;&lt; curDay &lt;&lt; endl; if(leftCheck(x,y)) { graph[y][x-1] = curDay+1; q.push(make_pair(y,x-1)); } if(rightCheck(x,y)) { graph[y][x+1] = curDay+1; q.push(make_pair(y,x+1)); } if(upCheck(x,y)) { graph[y-1][x] = curDay+1; q.push(make_pair(y-1,x)); } if(downCheck(x,y)) { graph[y+1][x] = curDay+1; q.push(make_pair(y+1,x)); }}void BFS(){ int curDay = 1; int x,y; while(q.size()!=0) { y = q.front().first; x = q.front().second; q.pop(); if(graph[y][x] == curDay) { checkAndMark(x,y,curDay); } else { curDay++; checkAndMark(x,y,curDay); } } for(int i=0;i&lt;M;i++) { for(int j=0;j&lt;N;j++) { if(graph[i][j] == 0) { cout &lt;&lt; -1; return; } //cout &lt;&lt; graph[i][j] &lt;&lt; &quot; &quot;; } //cout &lt;&lt; &quot;\\n&quot;; } cout &lt;&lt; curDay-1;}int main(){ //가로 = N //세로 = M cin &gt;&gt; N &gt;&gt; M; for(int i=0;i&lt;M;i++) { for(int j=0;j&lt;N;j++) { cin &gt;&gt; graph[i][j]; if(graph[i][j] == 1) { q.push(make_pair(i,j)); } } } BFS();}","link":"/2021/08/01/2021-prev/0313_graph_b7576/"},{"title":"Graph B2146","text":"개요백준 문제 2146번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 약 3시간https://www.acmicpc.net/problem/2146 문제이 나라는 N×N크기의 이차원 평면상에 존재한다. 이 나라는 여러 섬으로 이루어져 있으며, 섬이란 동서남북으로 육지가 붙어있는 덩어리를 말한다. 색이 있는 부분이 육지이고, 색이 없는 부분이 바다이다. 이 바다에 가장 짧은 다리를 놓아 두 대륙을 연결하고자 한다. 가장 짧은 다리란, 다리가 격자에서 차지하는 칸의 수가 가장 작은 다리를 말한다. 다음 그림에서 두 대륙을 연결하는 다리를 볼 수 있다. 지도가 주어질 때, 가장 짧은 다리 하나를 놓아 두 대륙을 연결하는 방법을 찾으시오. 계획한 풀이법풀이 방법) 번호를 메겨 섬을 체크 각 섬마다 BFS를 해가며 가장 짧은 거리의 다리를 찾는다 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 100;const int INF = 987654321;int mapSize = 0;int map[MAX][MAX];bool visit[MAX][MAX];//왼 오 상 하int check[4][2] = {{0,-1},{0,1},{-1,0},{1,0}};//섬 마킹void DFSMarking(int x, int y, int cnt){ visit[y][x] = true; map[y][x] = cnt; for (int i = 0; i &lt; 4; i++) { int nextY = y + check[i][0]; int nextX = x + check[i][1]; if (0 &lt;= nextY &amp;&amp; nextY &lt; mapSize &amp;&amp; 0 &lt;= nextX &amp;&amp; nextX &lt; mapSize) if (map[nextY][nextX] &amp;&amp; !visit[nextY][nextX]) DFSMarking(nextX, nextY, cnt); }}void BFSMarking2(int startX,int startY,int numberOfLand){ queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(startX,startY)); int nextX = 0; int nextY = 0; visit[startY][startX] = 1; map[startY][startX] = numberOfLand; while(q.size()!=0) { startX = q.front().first; startY = q.front().second; q.pop(); map[startY][startX] = numberOfLand; visit[startY][startX] = 1; for(int i=0;i&lt;4;i++) { nextY = startY + check[i][0]; nextX = startX + check[i][1]; if((nextX &gt;= 0 &amp;&amp; nextX &lt;mapSize) &amp;&amp; (nextY &gt;= 0 &amp;&amp; nextY &lt;mapSize)) { if(!visit[nextY][nextX] &amp;&amp; map[nextY][nextX]) { q.push(make_pair(nextX,nextY)); } } } }}int BFS(int land){ int count = 0; queue&lt;pair&lt;int,int&gt;&gt; q; int nextX,nextY,startX,startY; for(int i=0;i&lt;mapSize;i++) { for(int j=0;j&lt;mapSize;j++) { if(map[i][j] == land) { q.push(make_pair(j,i)); //cout &lt;&lt; &quot;값 : &quot; &lt;&lt; map[i][j] &lt;&lt; &quot; land : &quot; &lt;&lt; land &lt;&lt; &quot;\\n&quot;; //cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;pair 추가\\n&quot;; visit[i][j] = 1; } } } int qSize = 0; while(q.size() != 0) { qSize = q.size(); for(int k=0;k&lt;qSize;k++) { startX = q.front().first; startY = q.front().second; q.pop(); for(int i=0;i&lt;4;i++) { nextX = startX + check[i][1]; nextY = startY + check[i][0]; if((nextX &gt;= 0 &amp;&amp; nextX &lt; mapSize) &amp;&amp; (nextY &gt;= 0 &amp;&amp; nextY &lt; mapSize)) { if(map[nextY][nextX] &amp;&amp; map[nextY][nextX] != land) { return count; } else if(!(map[nextY][nextX]) &amp;&amp; !(visit[nextY][nextX])) { visit[nextY][nextX] = 1; q.push(make_pair(nextX,nextY)); } } } } count++; } }void init(){ cin &gt;&gt; mapSize; for(int i=0;i&lt;mapSize;i++) { for(int j=0;j&lt;mapSize;j++) { visit[i][j] = false; cin &gt;&gt; map[i][j]; } }}void solve(){ init(); int curX,curY,numberOfLand = 1,result = INF; for(int i=0;i&lt;mapSize;i++) { for(int j=0;j&lt;mapSize;j++) { if(!visit[i][j] &amp;&amp; map[i][j]) { DFSMarking(j,i,numberOfLand); numberOfLand++; } } } for(int land=1; land&lt;numberOfLand;land++) { fill(&amp;visit[0][0], &amp;visit[MAX-1][MAX] ,0); result = min(result,BFS(land)); } cout &lt;&lt; result;}int main(){ solve();} 막혔던 점 queue를 사용할때 반복문의 조건으로 q.size()를 사용했었는데처음에 의도한 것은 반복문을 시작할 때 q.size()만큼만 돌도록 하는 것이었으나q.size()를 사용하면 BFS를 돌면서 q의 크기가 바뀌게 되어서 의도한대로 실행되지 않았다.그래서 qSize라는 int 변수로 q.size()값을 저장하고 사용했다. 메모리 초과가 발생했는데 알고보니 섬 번호를 Marking하는 부분을 BFS로 구현했었는데그 때문인 것 같다.찾아보니 BFS는 큐로 탐색할 노드들을 다 저장하는 특성 상 공간복잡도가 복잡하다.DFS와 BFS의 특성에 대해서는 생각을 깊게 안해보았는데, 정리하자면 다음과 같다. BFS: 최단경로를 찾는데 유리하다(각 시도마다 여러 경로로 뻗어나가는 모양) DFS: 찾아야 하는 노드가 깊다면 유리하다(한번에 깊게 들어가는 모양) 느낀 점 이번 문제는 너무 코드 참조를 빠르게 한 것 같다(한시간 정도는 고민을 스스로 해야..)","link":"/2021/08/01/2021-prev/0315_graph_b2146/"},{"title":"Graph B1167","text":"개요백준 문제 1167번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 약 2시간https://www.acmicpc.net/problem/1167 문제트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오. 계획한 풀이법처음엔 간단히 생각해서 그냥 입력받은 뒤 DFS하면 될 줄 알았지만그렇지 않았다 왜냐하면 DFS는 가장 깊게 들어가게 되는데, 이 때 끝점과 시작점까지의 길이가 가장 긴 길이라고는 단정할 수 없다.가중치는 가장 큰 값인 것이 분명하지만, 그것과 별개로 현재 시작점과 가중치가 가장 큰 정점이 가장 길지 않는 경우도 있기 때문이다.그렇다면 가중치가 가장 높은 정점에서 DFS를 하게 되면 이때는 가중치가 가장 큰 정점이 시작점이니 여기서도 가장 큰 길이가 나오게 된다. 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAX = 100001;vector&lt;pair&lt;int, int&gt; &gt; graph[MAX];bool visit[MAX];int maxCost = 0;int maxCostNode = 0;int DFS(int startV,int cost){ if(visit[startV]) { return -1; } int result; visit[startV] = true; for(int i=0;i&lt;graph[startV].size();i++) { result = DFS(graph[startV][i].first,graph[startV][i].second+cost); if(result &gt; maxCost) { maxCost = result; maxCostNode = graph[startV][i].first; } } return cost;}void connectEdge(int v,int e,int length){ graph[v].push_back(make_pair(e,length));}void solve(){ int N = 0; cin &gt;&gt; N; int v = 0,e = 0,len = 0; for(int i=0;i&lt;N;i++) { v = 0,e = 0,len = 0; cin &gt;&gt; v &gt;&gt; e; while(e != -1) { cin &gt;&gt; len; connectEdge(v,e,len); cin &gt;&gt; e; } } fill_n(visit,MAX,false); for(int i=1;i&lt;=N;i++) { DFS(i,0); } maxCost = 0; fill_n(visit,MAX,false); DFS(maxCostNode,0); cout &lt;&lt; maxCost;}int main(){ //ios_base::sync_with_stdio(0); //cin.tie(0); solve();} 느낀 점 이 문제는 다른 사람의 풀이를 참조하고 이해하여 문제를 풀었다. 문제를 읽고 떠오른 방법에 대한 검증을 깊게 해보자(너무 단순하게 생각하지 말자)","link":"/2021/08/01/2021-prev/0316_graph_b1167/"},{"title":"Graph B11725","text":"개요백준 문제 11725번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 약 35분https://www.acmicpc.net/problem/11725 문제루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오. 계획한 풀이법문제를 보고 루트 없는 트리가 주어진다길래 무슨 말인가 했는데루트를 1이라고 생각하고 입력이 주어진다는 말이었다.풀이는 어쨌거나 트리는 최상위 루트가 존재해야하는데 그것이 1로 주어진다고 하여서 이를 힌트로 삼았다.기준을 1로(시작점) 잡으면 그 이후 부터는 BFS로 이동하기 전 노드가 이동하려는 노드의 부모 노드가 되니 이를 마킹하면 되는 문제이다. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//PM 6:17// 구상~ //PM 6:34// 구현~//PM 6:55//완#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int MAX = 100001;vector&lt;int&gt; graph[MAX];int visit[MAX];int N;void init(){ cin &gt;&gt; N; for(int i=0;i&lt;N+1;i++) { visit[i] = 0; }}void edgeBiConnect(int v,int e){ graph[v].push_back(e); graph[e].push_back(v);}//루트가 있을때 root -&gt; evoid edgeOneConnect(int v){ graph[1].push_back(v);}void BFS(int startV){ queue&lt;int&gt; q; int curV; for(int i=0;i&lt;graph[1].size();i++) { q.push(graph[1][i]); visit[graph[1][i]] = 1; } while(q.size() != 0) { curV = q.front(); q.pop(); for(int i=0;i&lt;graph[curV].size();i++) { if(visit[graph[curV][i]] == 0) { q.push(graph[curV][i]); visit[graph[curV][i]] = curV; } } }}void solve(){ int v,e; for(int i=0;i&lt;N;i++) { cin &gt;&gt; v &gt;&gt; e; if(v == 1) { edgeOneConnect(e); } else if(e == 1) { edgeOneConnect(v); } else { edgeBiConnect(v,e); } } BFS(1); for(int i=2;i&lt;=N;i++) { cout &lt;&lt; visit[i] &lt;&lt; &quot;\\n&quot;; }}int main(){ init(); solve();} 느낀 점 문제 자체는 쉬웠으나 한번에 고민한 것이 맞았고 코드도 나름 간결하게 짠 것 같아 만족한 풀이","link":"/2021/08/01/2021-prev/0316_graph_b11725/"},{"title":"Graph B1991","text":"개요백준 문제 1991번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 약 1시간https://www.acmicpc.net/problem/1991 문제이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오. 계획한 풀이법풀이 방법) 트리 생성 전위,중위,후위 순회를 재귀로 구현 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;int tree[26][2];void init(){ int n = 0; char rootVal,leftVal,rightVal; cin &gt;&gt; n; for(int i=0;i&lt;n;i++) { cin &gt;&gt; rootVal &gt;&gt; leftVal &gt;&gt; rightVal; tree[rootVal-'A'][0] = leftVal; tree[rootVal-'A'][1] = rightVal; }}void preOrder(char root){ if(root == '.') { return; } cout &lt;&lt; root; preOrder(tree[root-'A'][0]); preOrder(tree[root-'A'][1]);}void inOrder(char root){ if(root == '.') { return; } inOrder(tree[root-'A'][0]); cout &lt;&lt; root; inOrder(tree[root-'A'][1]);}void postOrder(char root){ if(root == '.') { return; } postOrder(tree[root-'A'][0]); postOrder(tree[root-'A'][1]); cout &lt;&lt; root;}void solve(){ preOrder('A'); cout &lt;&lt; &quot;\\n&quot;; inOrder('A'); cout &lt;&lt; &quot;\\n&quot;; postOrder('A');}int main(){ init(); solve();} 막혔던 점 위 코드는 다른사람의 코드를 보고나니 내 코드가 너무 안쓰러워서 다시 수정한 코드이다.연결리스트로 구현을 할려고 했는데, 입력을 한줄 씩 받으면서 재귀로 트리를 구성할려고 하니 N만큼 입력받는게전역함수를 추가하는 등 코드가 더러웠는데 역시 많이 상황에서 배열이 간단한 코드를 구성하는데 도움이 되는 것 같다. 느낀 점 코드를 쉽게 짜려는 것에 중점을 두자","link":"/2021/08/01/2021-prev/0316_graph_b1991/"},{"title":"Graph B1967","text":"개요백준 문제 1967번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 약 2시간https://www.acmicpc.net/problem/1967 문제트리(tree)는 사이클이 없는 무방향 그래프이다. 트리에서는 어떤 두 노드를 선택해도 둘 사이에 경로가 항상 하나만 존재하게 된다. 트리에서 어떤 두 노드를 선택해서 양쪽으로 쫙 당길 때, 가장 길게 늘어나는 경우가 있을 것이다. 이럴 때 트리의 모든 노드들은 이 두 노드를 지름의 끝 점으로 하는 원 안에 들어가게 된다. 이런 두 노드 사이의 경로의 길이를 트리의 지름이라고 한다. 정확히 정의하자면 트리에 존재하는 모든 경로들 중에서 가장 긴 것의 길이를 말한다. 입력으로 루트가 있는 트리를 가중치가 있는 간선들로 줄 때, 트리의 지름을 구해서 출력하는 프로그램을 작성하시오. 아래와 같은 트리가 주어진다면 트리의 지름은 45가 된다. 트리의 노드는 1부터 n까지 번호가 매겨져 있다. 계획한 풀이법이전에 푼 문제와 사실상 똑같은 문제였다.비교대상은 무엇이든 상관없으니 1로 시작하도록 하고 가장 가중치가 큰 정점을 찾아그 정점을 DFS하면 최대 길이가 나오게 된다. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;const int MAX = 10001;//메모리 초과vector&lt;pair&lt;int,int&gt;&gt; graph[MAX];int N = 0;bool visit[MAX];int maxCost = 0;int DFS(int startV){ stack&lt;pair&lt;int,int&gt;&gt; s; s.push(make_pair(startV,0)); int curV = 0; bool allVisited = false; int curCost = 0; int maxV = 0; while(s.size() != 0) { curV = s.top().first; if(!visit[curV]) { curCost += s.top().second; } visit[curV] = true; allVisited = true; if(maxCost &lt; curCost) { maxCost = curCost; maxV = curV; } for(int j=0;j&lt;graph[curV].size();j++) { int nextV = graph[curV][j].first; if(visit[nextV]) { continue; } int prevCost = graph[curV][j].second; s.push(make_pair(nextV, prevCost)); allVisited = false; break; } if(allVisited) { curCost -= s.top().second; s.pop(); } } return maxV;}void connectEdge(int v,int e,int cost){ //cout &lt;&lt; &quot;V , E 연결\\n&quot;; //cout &lt;&lt; v &lt;&lt; &quot;,&quot; &lt;&lt; e &lt;&lt; &quot;\\n&quot;; graph[v].push_back(make_pair(e,cost)); graph[e].push_back(make_pair(v,cost));}void init(){ cin &gt;&gt; N; int v,edge,cost; for(int i=0;i&lt;N-1;i++) { cin &gt;&gt; v &gt;&gt; edge &gt;&gt; cost; connectEdge(v,edge,cost); }}void solve(){ int maxV = DFS(1); fill_n(visit,MAX,0); DFS(maxV); cout &lt;&lt; maxCost;}int main(){ init(); solve();} 느낀 점 2시간 넘겨서 참고한 풀이가 바로 생각났는데 이래서는 내가 푼게 아닌 것 같은 기분이 들었다. 하지만 여러가지 시도를 해보니 이 방법이 맞구나 체감이 되어서 곧 바로 풀었다. 또 고집이 문제 풀이 시간을 눌렸다. 스스로가 생각한 풀이방법으로 풀린다면 얼마나 좋을까?하지만 그렇지 않은 경우가 앞으로 엄청나게 많을 것이다.그렇다고 기죽을 필요는 없는 것 같다.당연히 내가 잘하는 사람이 되기 전까지는 그 사람들의 뒷모습을 보는 것이 당연한 것이다.불만있으면 내가 잘하는 사람이 될때까지 더 열심히 해야 한다 지금은 결과주의자가 되자 문제를 빠르게 맞추는 것에만 집중하자 아직은 직관을 배워야 할 것 같다.","link":"/2021/08/01/2021-prev/0318_graph_b1967/"},{"title":"B1168","text":"개요백준 문제 1668번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : ???https://www.acmicpc.net/problem/1668 문제요세푸스 문제는 다음과 같다. 1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다.이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;using namespace std;const int MAX = 10001;int data[MAX];int N,K;int * tree;void initData(){ cin &gt;&gt; N &gt;&gt; K; int * tmp = (int *)malloc(sizeof(int) * ((N+1)* 4)); fill_n(tmp,(N+1)*4,-1); tree = tmp;}int initTree(int start,int end,int node,int * tree){ if(start == end) { return tree[node] = 1; } int mid = (start + end) / 2; return tree[node] = initTree(start,mid,node*2,tree) + initTree(mid+1,end,node*2+1,tree);}int getIdx(int start,int end,int node,int K){ if(start == end) { return start; } int mid = (start + end) / 2; if(K &lt;= tree[node * 2]) { return getIdx(start,mid,node * 2,K); } else { return getIdx(mid+1,end,node * 2 + 1,K - tree[node * 2]); }}void updateTree(int start,int end,int node,int idx){ if(idx &lt; start || idx &gt; end) { return; } tree[node]--; if(start == end) { return; } int mid = (start + end) / 2; updateTree(start,mid,node*2,idx); updateTree(mid+1,end,node*2+1,idx);} void solve(){ int deleteIdx = 0; int findIndex = 1; int remainNum = 0; initData(); initTree(1,N,1,tree); cout &lt;&lt; '&lt;'; for(int i=0;i&lt;N;i++) { remainNum = N - i; findIndex += K - 1; if(findIndex % remainNum == 0) { findIndex = remainNum; } else if(findIndex &gt; remainNum) { findIndex = findIndex % remainNum; } deleteIdx = getIdx(1,N,1,findIndex); updateTree(1,N,1,deleteIdx); cout &lt;&lt; deleteIdx; if(i != N-1) { cout &lt;&lt; &quot;, &quot;; } else { cout &lt;&lt; &quot;&gt;&quot;; } }}int main(){ initData(); solve();} 코드 수준 메모segment tree로 탐색을 Nlog(n)의 시간복잡도를 가지게 할 수 있어segment tree로 배열의 인덱스 합 트리를 구성한다.이후 삭제할려는 노드의 인덱스를 찾고 가져오면 되는데 그것은 getIdx 함수에서 한다.그 중 코드를 보면 return getIdx(mid+1,end,node * 2 + 1,K - tree[node * 2]);위 코드의 K - tree[node * 2]는 루트 노드에서 오른쪽으로 간다.이 말은 트리 구조상 오른쪽이기 때문에 이동할려는 인덱스 - 왼쪽 노드 인덱스를 해야정상적인 인덱스 비교를 할 수 있다 그렇지 않으면 오른쪽으로 한번 이동 한 뒤 항상 오른쪽으로 가게 된다.(루트보다 인덱스 값이 더 크기 때문에)간단하게는 루트 노드와 왼쪽 오른쪽 노드가 같은 인덱스 범위를 갖는다면 어떻게 할 것인지 생각하면 알 수 있다.update 함수는 삭제할려는 노드를 삭제하는 것인데 이것은 실제로는 해당하는 노드에서부터 루트까지 -1 해주면 삭제하는 효과를 얻을 수 있다. 소감 및 메모일단은 어려웠다 어려운 문제였고문제 자체는 저번에 풀었던 문제인데 그 문제에서 시간 제한이 빡빡해져서O(N^2)으로 풀면 시간초과가 나기 때문에이전 알고리즘보다 더 빠른 알고리즘을 채택해야하는데아직 경험이 부족해 그런 알고리즘을 스스로 생각하진 못하고 검색하여 segment tree를 찾아내어 공부를 했다.위 코드는 segment tree도 공부하고 여러 블로그에서 설명과 코드를 보면서 짠 코드라내 실력이라 말할 수 없다. 그냥 문제 많이 풀어야함 수구바위","link":"/2021/03/22/2021-prev/0322_b1168/"},{"title":"B2609","text":"개요백준 문제 2609번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : ???https://www.acmicpc.net/problem/2609 문제두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오. 코드1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;void LCM(int num1,int num2,int gcd){ cout &lt;&lt; ((num1 * num2) / gcd) &lt;&lt; &quot;\\n&quot;;}void GCD(int num1,int num2){ int tmpNum1 = num1; int tmpNum2 = num2; while(tmpNum2 != 0) { int r = tmpNum1 % tmpNum2; tmpNum1 = tmpNum2; tmpNum2 = r; } cout &lt;&lt; tmpNum1 &lt;&lt; endl; LCM(num1,num2,tmpNum1);}void solve(){ int num1,num2; cin &gt;&gt; num1 &gt;&gt; num2; GCD(num1,num2);}int main(){ solve();} 소감 및 메모예전에 배웠던 알고리즘인데 기억이 안남,,ㅋ최소공배수는 a * b / gcd인 점최대공약수는 그..네..외우죠,,ㅋ 유클리드 호제법입니다..!","link":"/2021/03/23/2021-prev/0322_b2609/"},{"title":"SEGMENT TREE","text":"개요segment tree 자료구조를 공부하고 정리한다. 공부하게 된 배경백준 1168 문제를 O(n^2)방법으로 풀었는데 시간초과가 발생하여더 좋은 풀이 방법을 찾지 못하던 중찾아보니 segment tree를 이용하면 O(NlogN)으로 풀 수 있다는 것을 발견하고segment tree를 알아보게 되었다. segment tree 개요segment tree는 일반적으로 트리 자체에 구간합을 가지고 있다.루트가 모든 합, 루트의 왼쪽에는 0~N/2까지,루트의 오른쪽은 N/2+1 ~ N-1까지의 구간 합을 가지는 식으로 트리가 구성된다.트리의 특징 상 필요한 합을 탐색하는데 시간복잡도는 O(logn)으로 선형적 자료구조에서 보다 빠름을 알 수 있다. segement tree 코드#include &lt;iostream&gt; using namespace std; const int MAX = 10001; int arr[MAX]; int N; int tree[MAX]; void init() { cin &gt;&gt; N; for(int i=0;i&lt;N;i++) { cin &gt;&gt; arr[i]; } } int makeSegmentTree(int start,int end,int node) { if(start == end) { return tree[node] = arr[node]; } int mid = (start+mid)/2; return tree[node] = makeSegmentTree(start,mid,node * 2) + makeSegmentTree(mid+1,end,node * 2 + 1); } int sumSegmentTree(int start,int end,int node,int left,int right) { if(left &gt; end || right &lt; start) { return 0; } //구간에 충족한다면 더 들어갈 필요 없이 리턴 if(left &lt;= start &amp;&amp; end &lt;= right) { return tree[node]; } int mid = (start + end)/2; return sumSegmentTree(start,mid,node*2,left,right) + sumSegmentTree(mid+1,end,node*2+1,left,right); } void updateSegmentTree(int start,int end,int node,int changeVal,int idx) { if(start &gt; idx || end &lt; idx) { return; } tree[node] += changeVal; //마지막 구간을 업데이트 하고 나면 더 깊게 들어갈 필요 없이 리턴 if(start == end) { return; } int mid = (start + end) / 2; updateSegmentTree(start,mid,node*2,changeVal,idx); updateSegmentTree(mid+1,end,node*2+1,changeVal,idx); } int main() { init(); makeSegmentTree(0,N-1,1); }","link":"/2021/03/22/2021-prev/0322_segementTree/"},{"title":"B9613","text":"개요백준 문제 9613번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 30분https://www.acmicpc.net/problem/9613 문제양의 정수 n개가 주어졌을 때, 가능한 모든 쌍의 GCD의 합을 구하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;const int MAX = 100;int GCD(int numA,int numB){ if(numA &lt; numB) { int tmp = numA; numA = numB; numB = tmp; } while(numB != 0) { int r = numA % numB; numA = numB; numB = r; } return numA;}void solve(){ int testCase; int numArr[MAX]; fill_n(numArr,MAX,0); cin &gt;&gt; testCase; for(int i=0;i&lt;testCase;i++) { int N = 0; long long sum = 0; cin &gt;&gt; N; for(int j=0;j&lt;N;j++) { cin &gt;&gt; numArr[j]; } for(int k=0;k&lt;N;k++) { for(int l=k+1;l&lt;N;l++) { sum += GCD(numArr[k],numArr[l]); } } cout &lt;&lt; sum &lt;&lt; &quot;\\n&quot;; }}int main(){ ios_base::sync_with_stdio(0); cin.tie(0); solve();} 풀이문제 그대로 GCD를 구현해서 합하면 되는 문제단, sum이 int의 범위를 넘어간다는 것 때문에 틀렸음그냥 단순한 구현 문제라서 딱히 어렵진 않았음","link":"/2021/03/23/2021-prev/0323_b1850/"},{"title":"B1934","text":"개요백준 문제 1934번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 10분https://www.acmicpc.net/problem/1934 문제두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;void LCM(int numA,int numB){ int addedNum = numB; while(addedNum % numA != 0) { addedNum += numB; } cout &lt;&lt; addedNum &lt;&lt;&quot;\\n&quot;;}void solve(){ int testCase,numA,numB; cin &gt;&gt; testCase; for(int i=0;i&lt;testCase;i++) { cin &gt;&gt; numA &gt;&gt; numB; LCM(numA,numB); }}int main(){ solve();} 풀이둘 중에 한 값을 A라고 했을 때 A는 계속 A를 더하면서 더해진 값 % B == 0인지 확인한다.","link":"/2021/03/23/2021-prev/0323_b1934/"},{"title":"B9613","text":"개요백준 문제 9613번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 10분https://www.acmicpc.net/problem/9613 문제양의 정수 n개가 주어졌을 때, 가능한 모든 쌍의 GCD의 합을 구하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;const int MAX = 100;int GCD(int numA,int numB){ if(numA &lt; numB) { int tmp = numA; numA = numB; numB = tmp; } while(numB != 0) { int r = numA % numB; numA = numB; numB = r; } return numA;}void solve(){ int testCase; int numArr[MAX]; fill_n(numArr,MAX,0); cin &gt;&gt; testCase; for(int i=0;i&lt;testCase;i++) { int N = 0; long long sum = 0; cin &gt;&gt; N; for(int j=0;j&lt;N;j++) { cin &gt;&gt; numArr[j]; } for(int k=0;k&lt;N;k++) { for(int l=k+1;l&lt;N;l++) { sum += GCD(numArr[k],numArr[l]); } } cout &lt;&lt; sum &lt;&lt; &quot;\\n&quot;; }}int main(){ ios_base::sync_with_stdio(0); cin.tie(0); solve();} 풀이쌍이라길래 중복되는 부분을 없애주어야하나 생각을 했는데 그렇진 않은 것 같다.그냥 무지성 GCD,LCM으로 풀면 됨 배운 점123ios_base::sync_with_stdio(0);cin.tie(0);//속도 향상에 도움됨 쓰는 습관 기르기","link":"/2021/03/28/2021-prev/0323_b9613/"},{"title":"B11005","text":"개요백준 문제 11005번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 30분https://www.acmicpc.net/problem/11005 문제10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오. 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다. A: 10, B: 11, …, F: 15, …, Y: 34, Z: 35 코드123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void solve(){ vector &lt;int&gt; v; long long num,digit; int result; cin &gt;&gt; num &gt;&gt; digit; while(num != 0) { v.push_back(num % digit); num /= digit; } vector&lt;int&gt;::reverse_iterator iter; for(iter = v.rbegin();iter != v.rend();iter++) { if(*iter &gt;= 10) { cout &lt;&lt; (char(*iter - 10+'A')); } else { cout &lt;&lt; *iter; } }}int main(){ solve();} 풀이우선 진법 변환을 하면서 결과를 저장한다이후 저장된 결과를 끝에서 부터 조건(10이상은 알파벳 등)에 맞춰 출력한다 배운 점, 메모c++ 벡터 문법적인 부분을 배웠다 12vector&lt;int&gt;::reverse_iterator iter; // 거꾸로 진행되는 iteration for(iter = v.rbegin();iter != v.rend();iter++) // 인덱스 끝에서부터 인덱스 맨 앞까지 iteation 진행","link":"/2021/03/28/2021-prev/0328_b11005/"},{"title":"B2745","text":"개요백준 문제 2745번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 30분https://www.acmicpc.net/problem/2745 문제B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.A: 10, B: 11, …, F: 15, …, Y: 34, Z: 35 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void solve(){ string inputStr; int digit; long long result = 0; int curNum = 0; stack&lt;int&gt; s; cin &gt;&gt; inputStr &gt;&gt; digit; for(int i=0;i&lt;inputStr.size();i++) { if (inputStr[i] &gt;= '0' &amp;&amp; inputStr[i] &lt;= '9') { curNum = inputStr[i] - '0'; } else { curNum = inputStr[i] - 'A' + 10; } s.push(curNum); } int stackSize = s.size(); int digitTmp = 1; for(int i=0;i&lt;stackSize;i++) { curNum = s.top(); s.pop(); result = result + curNum * digitTmp; digitTmp *= digit; } cout &lt;&lt; result;}int main(){ solve();} 풀이 조건(알파벳 - 숫자 맵핑)에 맞춰 숫자로 변환한 값을 스택에 넣는다. 스택에 넣었으므로 입력된 순서의 역 즉 1의 자리부터 계산할 수 있다. 진수에 맞춰 자리수를 곱하고 값을 더한다. 배울 점, 메모 쉬운 문제지만 꼼꼼히 생각하고 소홀히 하지 말 것 간단한 구현도 꼼꼼하게 생각할 것 쉬운 문제라고 생각을 적게하려는 것 고치기= 자만하지 않기 쉬운 문제를 풀때도 차분함을 공부한다고 생각하고 임하기","link":"/2021/03/28/2021-prev/0328_b2745/"},{"title":"B2110","text":"개요백준 문제 B2110번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 60분https://www.acmicpc.net/problem/2110 문제도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, …, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다. 도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다. C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAX = 200001;int home[MAX];int maxLen = 0;int countNum = 0;int checkPosibleInstall(int distance){ int count = 1; int curHome = home[0]; for(int i=1;i&lt;countNum;i++) { if(distance &lt;= home[i] - curHome) { count++; curHome= home[i]; } } return count;}void binarySearch(int start,int end,int haveToInstall){ if(start &gt; end) { return; } int mid = (start + end) / 2; int installedCount = checkPosibleInstall(mid); if(installedCount &gt;= haveToInstall) { maxLen = max(maxLen,mid); binarySearch(mid+1,end,haveToInstall); } else { binarySearch(start,mid-1,haveToInstall); }}void solve(){ int N,installNum; cin &gt;&gt; N &gt;&gt; installNum; for(;countNum&lt;N;countNum++) { cin &gt;&gt; home[countNum]; } sort(home,home+countNum); int distance = home[countNum-1] - home[0]; binarySearch(1,distance,installNum); cout &lt;&lt; maxLen;}int main(){ solve();} 풀이* 웹에서 참고 많이한 문제 문제 풀이는 우선 동적계획법과 비슷한 느낌으로정해진 간격을 두고 일단 설치한 뒤에 조건을 돌아보는 식으로 풀 수 있다.자세히는 설치하는 공유기들은 이전에 설치된 공유기와 간격값이 크거나 같아야 한다.(주어진 간격보다 적으면 안되니까)이 조건으로 우선 설치를 한 뒤에설치할 수 있는 수와 비교하여 간격을 줄이거나 늘리는 방법으로 답을 찾을 수 있다. 배울 점, 메모이 문제를 보고 생겼던 의문점 하나이분 탐색인데 정렬이 안되어서 입력이 들어온다 -&gt; 정렬해야하지 않나? =&gt; YESlogN에 풀어야하는데 기존 정렬함수는 효율적으로 잘 짜여져있어 사용해도 됨. 문제를 읽고 생각을 해봤는데 자신의 생각에 확신이 안들어 금방 포기해버렸다.간격을 항상 같아야 한다고 생각했는데 사실 간격보다 크기만 하면 되는 것이었다.일단 설치한 뒤에 조건을 돌아보는 방식을 생각하지 못하여서 어떻게 구현할지 조차 감이 안잡혔다. 어떻게 개선할까 한 문제당 최소 30분 이상은 안풀리더라도 구현하지않고 생각하자 생각 및 구현이 1 시간이 넘어가지 않는다면 무조건 자신감 갖고 그냥 생각한대로 구현해보자 이것이 필요한 이유는 첫번째로 자신의 생각에 자신감을 갖기 위함 두번째로 틀리거나 모르겠어도 배울점이 많을 것이기 때문이다","link":"/2021/04/06/2021-prev/0406-B2110/"},{"title":"B2805","text":"개요백준 문제 2805번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 60분https://www.acmicpc.net/problem/2805 문제상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다. 목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다. 상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오. 코드#include using namespace std;const long long MAX = 1000000;const long long INF = 987654321;long long tree[MAX];long long count;long long maxCuttingHeight = 0; bool isCutted(long long idx,long long cuttingHeight){ if(tree[idx] &gt; cuttingHeight) { return true; } return false;} void binarySearch(long long start,long long end,long long wantedHeight){ if(start &gt; end) { cout &lt;&lt; maxCuttingHeight; return; } long long cuttingHeight = (start + end) / 2; long long cutResult = 0; for(long long i=0;i&lt;count;i++) { if(isCutted(i,cuttingHeight)) { cutResult += tree[i] - cuttingHeight; } } if(wantedHeight &lt;= cutResult) { maxCuttingHeight = max(maxCuttingHeight,cuttingHeight); binarySearch(cuttingHeight+1,end,wantedHeight); } else { binarySearch(start,cuttingHeight-1,wantedHeight); } } void solve(){ long long N,wantedHeight; long long maxHeight = 0; cin &gt;&gt; N &gt;&gt; wantedHeight; for(count=0;count&lt;N;count++) { cin &gt;&gt; tree[count]; maxHeight = max(maxHeight,tree[count]); } binarySearch(0,maxHeight,wantedHeight); } int main(){ solve();} 풀이이진탐색 응용문제로,입력 중 가장 큰 값을 토대로 이진탐색을 진행한다.진행하며 조건에 맞는 값 중 가장 큰 값을 찾는다.조심할 점은 입력으로 1 1 1이 주어진 경우 절단기의 높이가 0이어야하므로시작점을 0으로 설정해야 한다.또한 범위에 유의하여 자료형을 설정해야 한다. 배울 점, 메모","link":"/2021/04/06/2021-prev/0406-B2805/"},{"title":"B10872","text":"개요백준 문제 10872번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 10분https://www.acmicpc.net/problem/10872 문제0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오. 코드1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;void solve(){ int num; cin &gt;&gt; num; if(num == 0) { cout &lt;&lt; 1; return; } else { int result = 1; while(num != 1) { result *= num ; num--; } cout &lt;&lt; result; }}int main(){ solve(); } 풀이배울 점, 메모","link":"/2021/04/05/2021-prev/0406_B10872/"},{"title":"B1654","text":"개요백준 문제 A번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 1분https://www.acmicpc.net/problem/1654 문제집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다. 이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.) 편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오. 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;using namespace std;const long long MAX = 10000;long long line[MAX];long long count = 0;long long resultLen = 0;long long binarySearch(long long start,long long end,long long objVal){ long long divUnit = (start + end) / 2; long long lineCount = 0; if(start &gt; end) { return 0; } for(long long i=0;i&lt;count;i++) { lineCount += (line[i] / divUnit); } if(lineCount &gt;= objVal) { if(resultLen &lt; divUnit) { resultLen = divUnit; } binarySearch(divUnit+1,end,objVal); return divUnit; } else { return binarySearch(start,divUnit-1,objVal); }}void solve(){ long long haveLine,makeLine; cin &gt;&gt; haveLine &gt;&gt; makeLine; long long maxLen = 0; long long result = 0; for(count=0;count&lt;haveLine;count++) { cin &gt;&gt; line[count]; result += line[count]; maxLen = max(maxLen,line[count]); } binarySearch(1,maxLen,makeLine); cout &lt;&lt; resultLen;}int main(){ solve();} 풀이우선 이분탐색으로 풀이하는 문제임을 안 상태였고,따라서 이분탐색을 이용하여서 풀 수 있는 방법을 생각해보면최대 랜선 길이를 end라 두고 이분탐색을 진행하면 된다.이 때, 원하는 개수를 만들었더라도 최대 길이를 찾아야 하므로최대 개수를 찾은 상태 -&gt; 원하는 개수가 만들어지지 않을 때 까지 계산하여 최대 길이를 찾으면 된다. 배울 점, 메모풀이방법 자체는 잘 생각했으나,이분탐색에서 왼쪽 탐색 시 end = mid -1, 오른쪽 탐색 시 start = mid + 1를 명시해야 하는데 이 부분 미흡했다.또한 입력 값의 범위가 int로 주어지지만 계산 시 int 범위를 넘어가기 때문에 long long으로 바꿔줘야 한다.","link":"/2021/04/06/2021-prev/0406_B1654/"},{"title":"B1676","text":"개요백준 문제 1676번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 30분https://www.acmicpc.net/problem/1676 문제N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;void solve(){ int num = 0; cin &gt;&gt; num; int five=0; for(int i=5;i&lt;=num;i*=5) { five += num / i; } cout &lt;&lt; five;}int main(){ solve();} 풀이우선 팩토리얼을 그대로 연산하면 시간초과가 뜬다는 것을 파악했다.그렇다면 팩토리얼 연산을 하지 않고 어떻게 0의 개수를 파악할까?정답은 0의 개수 = 10의 개수였다.따라서 어떤 숫자 N에 대해 2와 5의 갯수를 찾고그 중 최소값(여기서 최소값은 2와 5가 쌍을 이룰 수 있는 개수)를 찾으면 된다.하지만 생각해보면 5의 개수는 항상 2의 개수보다 적다 따라서 2는 무시하고 5의 개수만 찾으면 된다. 배울 점, 메모보통 이런 수학 문제를 만나면 머리가 멍해지는데,문제를 작게 분해하고 규칙을 찾는 것이 중요한 것 같다.","link":"/2021/04/05/2021-prev/0406_B1676/"},{"title":"B1929","text":"개요백준 문제 1929번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 30분https://www.acmicpc.net/problem/1929 문제M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;const int MAX = 1000001;bool check[MAX]; using namespace std;void solve(){ fill_n(check,MAX,false); check[1] = true; int M,N; cin &gt;&gt; M &gt;&gt; N; for(int i=2;i&lt;=N;i++) { for(int j=2; i*j &lt;= N;j++) { check[i*j] = true; } } for(int i=M;i&lt;=N;i++) { if(!check[i]) { cout &lt;&lt; i &lt;&lt;&quot;\\n&quot;; } }}int main(){ solve();} 풀이문제를 읽고 일반적으로 생각하는 A-1숫자부터 2까지 나머지를 체크하는 방식은 시간초과가 뜰 것 같았다.그 다음으로는 짝수인 경우가 많을 것이라 생각하여 숫자 (A-1 % 2) == 0 이면 break하도록하여 조금 더 개선했지만이렇게는 시간복잡도는 줄어들지 않는다.여기서 아예 내가 모르는 방법이 있구나 하여 검색해보았다.찾아보니 에라토스테네스의 체라는 방법이 있었다(A-1 % 2)에서 2 대신 2부터 최대 범위가 되기 전까지의 수를2부터 곱한 것(2부터 하는 이유는 자기자신을 제외하기 위해)에 마킹을 한다.연산을 다 마치고 나면 마킹이 되지 않은 것은 소수라는 의미이다. 배울 점, 메모이번 문제는 한 30분 생각하다 검색해서 정답을 알게 된 문제인데내 스스로 생각하여 완벽하게 풀지 못한 것이 마음에 걸렸다.내가 오랫동안 생각했다면 풀 수 있었을까?오랫동안 생각했다면 그럴만한 가치가 있는가?라는 생각이 곧 떠올랐다.스스로 생각해본 결과 1시간 이상 넘어간다면 모르는 것으로 간주하고여러 유형을 배우고 익히는 것이 먼저라는 결론이 나왔다.항상 스스로 할려고 하는 것은 나쁜게 아니지만,엄청나게 많은 문제를 풀기 위해서는 조금 다르게 생각해야 할 것 같다결과론적으로 생각해봤을 때 알고리즘을 잘하는 방법은 많이 풀어보는 수 밖에 없기 때문에오랫동안 생각했다면 풀 수 있었더라도, 문제를 풀지 못해 스스로에게 실망하더라도좌절한 시간조차도 노력으로 나중의 나에게 돌려주면 된다고 생각한다.","link":"/2021/04/05/2021-prev/0406_B1929/"},{"title":"B1978","text":"개요백준 문제 1978번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 5분https://www.acmicpc.net/problem/1978 문제주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오. 코드123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;const int MAX = 1001;using namespace std;void solve(){ int N,curNum,count = 0; int objNum; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) { cin &gt;&gt; curNum; if(curNum == 2) { count++; } for(int i=2;i&lt;curNum;i++) { if(curNum % i == 0) { break; } if(i+1 == curNum) { count++; } } } cout &lt;&lt; count;}int main(){ solve();} 풀이메모라이즈 기법을 사용해 시간을 좀 줄일까 생각했지만 굳이 그럴 것 없이숫자 2부터 Num-1까지 일일이 나눠지는지 확인했다.숫자 2의 경우는 예외처리 했다. 배울 점, 메모못하는만큼 열심히","link":"/2021/04/02/2021-prev/0406_B1978/"},{"title":"B2004","text":"개요백준 문제 2004번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 1시간 30분https://www.acmicpc.net/problem/2004 문제nCm의 끝자리 의 개수를 출력하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;long long getCountFromFact(long long n){ long long five = 0; for(long long i=5;i&lt;=n;i*=5) { five += n/i; } return five;}long long getCountFromFactTwo(long long n){ long long two = 0; for(long long i=2;i&lt;=n;i*=2) { two += n/i; } return two;}int getCountFromNum(string str){ int count = 0; for(int i=str.size()-1;i&gt;=0;i--) { if(str[i] != '0') { return count; } count++; }}void solve(){ long long n,c; cin &gt;&gt; n &gt;&gt; c; c = min(n-c,c); long long upper,mid; long long upperTwo,midTwo; if(c == 0) { cout &lt;&lt; 0; } else if(c == 1) { cout &lt;&lt; getCountFromNum(to_string(n)); } else { upper = getCountFromFact(n); mid = getCountFromFact(n-c) + getCountFromFact(c); upperTwo = getCountFromFactTwo(n); midTwo = getCountFromFactTwo(n-c) + getCountFromFactTwo(c); cout &lt;&lt; min((upper - mid),(upperTwo-midTwo)); } }int main(){ solve(); } 풀이이전에 배웠던 팩토리얼을 직접 계산하지않고 0을 추출하는 것을 이용한 문제이다.(2와 5의 쌍의 갯수를 계산하여 푸는 방법)팩토리얼 0의 갯수 구하기 문제에서는 2가 의미가 없었다 (항상 5의 개수가 적어서)하지만 이번 문제도 동일하게 생각해서 풀었는데, 나눠지는 팩토리얼에서 2를 나누면나누는 팩토리얼에 영향을 주게되므로 2의 개수도 고려해야 했다. 배울 점, 메모오늘로 6문제를 풀어보았는데,스스로 완벽하게 푼 문제는 기초문제들 뿐이었다.하지만 어떡하겠는가?완벽하게 안다면 배울 필요가 없지 않는가","link":"/2021/04/05/2021-prev/0406_B2004/"},{"title":"B6588","text":"개요백준 문제 6588번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 60분https://www.acmicpc.net/problem/6588 문제1742년, 독일의 아마추어 수학가 크리스티안 골드바흐는 레온하르트 오일러에게 다음과 같은 추측을 제안하는 편지를 보냈다.4보다 큰 모든 짝수는 두 홀수 소수의 합으로 나타낼 수 있다.예를 들어 8은 3 + 5로 나타낼 수 있고, 3과 5는 모두 홀수인 소수이다. 또, 20 = 3 + 17 = 7 + 13, 42 = 5 + 37 = 11 + 31 = 13 + 29 = 19 + 23 이다.이 추측은 아직도 해결되지 않은 문제이다.백만 이하의 모든 짝수에 대해서, 이 추측을 검증하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;const int MAX = 1000001;int problem[MAX];bool check[MAX];int frontVal[MAX];int backVal[MAX];void checkPrimeNum(int val){ for(int i=2;i&lt;=val;i++) { for(int j=2;i*j&lt;=val;j++) { check[i*j] = true; } }}void solve(){ int val = -1; int count = 0; int maxVal = 0; fill_n(problem,MAX,0); fill_n(frontVal,MAX,0); fill_n(check,MAX,false); fill_n(backVal,MAX,0); do { cin &gt;&gt; val; if(val != 0) { problem[count++] = val; } if(maxVal &lt; problem[count-1]) { maxVal = problem[count-1]; } }while(val != 0); checkPrimeNum(maxVal); for(int testCase=0;testCase&lt;count;testCase++) { for(int iter = 3;iter &lt; problem[testCase]; iter++) { if(!check[iter] &amp;&amp; !check[problem[testCase] - iter]) { cout &lt;&lt; problem[testCase] &lt;&lt; &quot; = &quot; &lt;&lt; iter &lt;&lt; &quot; + &quot; &lt;&lt; problem[testCase] - iter&lt;&lt; &quot;\\n&quot;; break; } } } }int main(){ solve();} 풀이이전에 배웠던 알고리즘인 에라스토테네스의 채 알고리즘으로 해결할 수 있는 문제이다.처음에는 이 접근 방식 자체는 맞았지만 시간 초과가 뜨길래 뭔가 더 최적화 해야하는 줄 알고 몇가지 시도를 했었으나 그것이 문제가 아니었고 내 코드의 문제는 다음과 같았다.if(!check[iter] &amp;&amp; !check[problem[testCase] - iter])이 부분은 앞의 값 + 뒤의 값 = 더한 값이면서 소수인 값을 찾는 부분인데,나는 이 뒤의 값을 찾을때 바보같이 더한 값에서부터 -1을 하면서 찾았다.그냥 당연히 A + B = C라면 B = C - A인데 이 점을 생각하지 못했다..어쨌건 그부분은 검색을 통해 알아냈고 수정하니 바로 AC가 떴다. 배울 점, 메모좀..수학이 약한듯문제에서부터 어떤 규칙이나 명백한 식같은걸 이끌어 내야함","link":"/2021/04/05/2021-prev/0406_B6588/"},{"title":"1107","text":"i write this post at 1107. About Current Studyhave to write more oftenly currently i’m doing CRF feature things current problem is that if there is so many data that memory would be down.. how to solve this problem..well i thing this problem is have to access with engineering concept first, i should understand feature is how interactive each other in inference level and analysis… What i have feltwith those month i get those things: 1.nobody but you is the person that knows your code so you have to get into your code perfectly and you should love your code 2.hard work is perfectly loveable because it is only thing that express you perfectly 3.just start thing every day that making you a better person even maybe it’s small. 4.just don’t care about other eyes just focus inside of you. 5.mostly human are not good at multi task it doesn’t help your concentration you should have to watch a one thing at one time 6.more fun and impressive more you know. 7.always try to be your 100%, always say why and more to yourself 8.always find fun whatever you do, always have art inside heart.","link":"/2021/08/01/2021-prev/1107/"},{"title":"B10610","text":"개요백준 문제 10610번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 60분https://www.acmicpc.net/problem/10610 문제어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다. 미르코를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라. 코드123어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다.미르코를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라. 풀이기초 수학을 이용해야 하는 문제30의 배수이므로 0이 포함돼야하며각 자리수를 더했을 때 3의 배수라면 30의 배수임 배울 점, 메모","link":"/2021/05/11/2021-prev/B10610/"},{"title":"B11047","text":"개요백준 문제 11047번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 20분https://www.acmicpc.net/problem/11047 문제동전을 적절히 사용해서 주어진 가치 K를 만들어야함 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;const int MAX = 10;int coinVal[MAX];int N;int objVal;void greedy(){ int sum = 0; int valIdx = N-1; int countAddCoin = 0; while(objVal != sum) { if(sum + coinVal[valIdx] &gt; objVal) { valIdx--; } else { sum += coinVal[valIdx]; countAddCoin++; } } cout &lt;&lt; countAddCoin;}void solve(){ cin &gt;&gt; N &gt;&gt; objVal; for(int i=0;i&lt;N;i++) { cin &gt;&gt; coinVal[i]; } greedy();} int main(){ solve();} 풀이항상 1원짜리가 들어와서 걱정없이 그리디를 적용할 수 있음.K를 넘지않는 제일 큰 동전을 추가하면 해결 배울 점, 메모","link":"/2021/05/11/2021-prev/B11047/"},{"title":"B11399","text":"개요백준 문제 11399번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 10분https://www.acmicpc.net/problem/11399 문제인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다. 사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다. 줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다. 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. 코드123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; v;void solve(){ int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) { int time; cin &gt;&gt; time; v.push_back(time); } sort(v.begin(),v.end()); //소요시간 int sumTime = 0; //소요시간 + 현재 소요 시간 int resultTime = 0; for(int i=0;i&lt;N;i++) { sumTime += v[i]; resultTime += sumTime; } cout &lt;&lt; resultTime;}int main(){ solve(); } 풀이그리디..?까지 생각하지 않아도 걸리는 시간이 적은 순으로 정렬한 뒤소요시간은 더하면 되는 문제운영체제의 스케줄링에서 입력이 동시에 왔을 때 SJT 정책과 동일하게 생각하면 된다. 배울 점, 메모이렇게 쉬운 문제인데도 식이나 코드가 바로 나오지 않았는데수학적인 면이나 생각을 빠르게 이끌어내는 연습이 부족한 것 같다.","link":"/2021/05/13/2021-prev/B11399/"},{"title":"B11576","text":"개요백준 문제 11576을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 1시간 https://www.acmicpc.net/problem/11576 문제타임머신을 개발하는 정이는 오랜 노력 끝에 타임머신을 개발하는데 성공하였다. 미래가 궁금한 정이는 자신이 개발한 타임머신을 이용하여 500년 후의 세계로 여행을 떠나게 되었다. 500년 후의 세계에서도 프로그래밍을 하고 싶었던 정이는 백준 사이트에 접속하여 문제를 풀기로 하였다. 그러나 미래세계는 A진법을 사용하고 있었고, B진법을 사용하던 정이는 문제를 풀 수가 없었다. 뛰어난 프로그래머였던 정이는 A진법으로 나타낸 숫자를 B진법으로 변환시켜주는 프로그램을 작성하기로 하였다. N진법이란, 한 자리에서 숫자를 표현할 때 쓸 수 있는 숫자의 가짓수가 N이라는 뜻이다. 예를 들어 N은 17일 때 한 자릿수에서 사용할 수 있는 수는 0, 1, 2, … , 16으로 총 17가지가 된다. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;int returnTenDigitNum(int digit){ int N; cin &gt;&gt; N; int digitNum = 1; int result = 0; int curNum = 0; for(int i=0;i&lt;N;i++) { cin &gt;&gt; curNum; result = result * digit + curNum; } return result;}void solve(){ int objDigit,subjDigit; int tenDigitNum; int maxObjDigitNum = 1; cin &gt;&gt; subjDigit &gt;&gt; objDigit; tenDigitNum = returnTenDigitNum(subjDigit); //cout &lt;&lt; &quot;ten digit : &quot; &lt;&lt; tenDigitNum &lt;&lt; &quot;\\n&quot;; if(tenDigitNum == 0) { cout &lt;&lt; tenDigitNum; } else { while(maxObjDigitNum &lt;= tenDigitNum) { maxObjDigitNum *= objDigit; } maxObjDigitNum /= objDigit; //cout &lt;&lt; &quot;최대 자리수 : &quot; &lt;&lt; maxObjDigitNum &lt;&lt; &quot;\\n&quot;; int result = 0; while(tenDigitNum != 0) { result = tenDigitNum / maxObjDigitNum; cout &lt;&lt; result; tenDigitNum = tenDigitNum % maxObjDigitNum; maxObjDigitNum /= objDigit; if(tenDigitNum != 0) { cout &lt;&lt; &quot; &quot;; } } } }int main(){ solve();} 풀이N 진법 -&gt; 10진법 -&gt; M진법으로 변환한다. 배울 점, 메모풀이 방식 접근 자체는 틀린것이 아닌데 세부적으로 구현할 때 == 같은 부분을 놓쳤다아직 세밀한 코딩 능력이 부족한것 같다.아직 잘 못하니까 공부하는 것이다 쉬운데 빠르게 못푼다고 기죽지말자","link":"/2021/04/01/2021-prev/B11576/"},{"title":"B11622","text":"개요백준 문제 11622번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 90분https://www.acmicpc.net/problem/11622 문제민호와 강호가 2차원 좌표 평면 위에 있다. 민호는 점 A(Ax, Ay)에서 점 B(Bx, By)를 향해 걸어가고 있고, 강호는 점 C(Cx, Cy)에서 점 D(Dx, Dy)를 향해 걸어가고 있다. 민호와 강호는 동시에 출발하고, 민호가 점 B에 도착하는 순간 강호도 점 D에 도착한다. 또, 두 사람은 항상 일정한 속도로 걸어간다. 두 사람의 거리가 가장 가까울 때, 거리를 구하는 프로그램을 작성하시오. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef struct{ double x; double y;}point;double calDistance(point A,point B){ return pow(A.x-B.x,2) + pow(A.y-B.y,2);}void setPoint(point * A,point * B,point * C,point * D){ int Ax,Bx,Cx,Dx; int Ay,By,Cy,Dy; cin &gt;&gt; Ax &gt;&gt; Ay &gt;&gt; Bx &gt;&gt; By; cin &gt;&gt; Cx &gt;&gt; Cy &gt;&gt; Dx &gt;&gt; Dy; A-&gt;x = Ax; A-&gt;y = Ay; B-&gt;x = Bx; B-&gt;y = By; C-&gt;x = Cx; C-&gt;y = Cy; D-&gt;x = Dx; D-&gt;y = Dy;}point getPoint(double k,point A,point B){ point resultPoint; resultPoint.x = A.x + (B.x - A.x) * (k/100); resultPoint.y = A.y + (B.y - A.y) * (k/100); return resultPoint; }void solve(){ point A,B,C,D; setPoint(&amp;A,&amp;B,&amp;C,&amp;D); double minResult = 987654321; double fp = 0,lp=100,limit=2e9; double distA,distB; while(lp-fp&gt;=1e-10) { double k1 = (fp*2 + lp) / 3; double k2 = (fp + lp * 2) / 3; point curPointAB_1 = getPoint(k1,A,B); point curPointCD_1 = getPoint(k1,C,D); point curPointAB_2 = getPoint(k2,A,B); point curPointCD_2 = getPoint(k2,C,D); distA = calDistance(curPointAB_1,curPointCD_1); distB = calDistance(curPointAB_2,curPointCD_2); minResult = min(minResult,min(distA,distB)); if(distA &gt;= distB) { fp = k1; } else { lp = k2; } } cout &lt;&lt; sqrt(minResult);}int main(){ cout &lt;&lt; fixed; cout.precision(6); solve();} 풀이이분탐색으로 풀려고 했는데, 이분탐색의 경우 mid값을 정하는데 애매한 부분이 있고실제로 이 문제에서는 오차문제로 인해 잘 풀리지 않는다.삼분탐색이나 미적분을 이용한 방법이 있었는데 삼분탐색을 보고 카피해 풀었다. 배울 점, 메모이분탐색 = 명확한 값 변화가 있을 때범위,근사값 등이면서 볼록함수 형태 = 삼분탐색","link":"/2021/04/30/2021-prev/B11622/"},{"title":"B11653","text":"개요백준 문제 11653번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 10분https://www.acmicpc.net/problem/11653 문제소인수분해 구하기 코드123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;void solve(){ int num; int modNum = 2; cin &gt;&gt; num; while(num != 1 &amp;&amp; num != 0) { if(num % modNum == 0) { cout &lt;&lt; modNum &lt;&lt; endl; num /= modNum; } else { modNum++; } }}int main(){ solve();} 풀이배울 점, 메모","link":"/2021/04/05/2021-prev/B11653/"},{"title":"B11728","text":"개요백준 문제 11728번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 20분https://www.acmicpc.net/problem/11728 문제정렬되어있는 두 배열 A와 B가 주어진다.두 배열을 합친 다음 정렬해서 출력하는 프로그램을 작성하시오. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;const int MAX = 1000000;int arrA[MAX],arrB[MAX];int resultArr[MAX];void merge(int N,int M){ int k = 0; int i,j; for(i=0,j=0;i &lt; N &amp;&amp; j &lt; M;) { if(arrA[i] &gt; arrB[j]) { resultArr[k++] = arrB[j++]; } else { resultArr[k++] = arrA[i++]; } } while(i &lt; N) { resultArr[k++] = arrA[i++]; } while(j &lt; M) { resultArr[k++] = arrB[j++]; }}void solve(){ int N,M; cin &gt;&gt; N &gt;&gt; M; for(int i=0;i&lt;N;i++) { cin &gt;&gt; arrA[i]; } for(int i=0;i&lt;M;i++) { cin &gt;&gt; arrB[i]; } merge(N,M); for(int i=0;i&lt;N+M;i++) { cout &lt;&lt; resultArr[i]; if(i+1 != N+M) { cout &lt;&lt; &quot; &quot;; } }}int main(){ ios_base :: sync_with_stdio(0); cin.tie(0); solve();} 풀이 정렬된 두 배열이라는 점 합친다음 출력한다=&gt; merge sort에서의 분할을 제외한 부분과 동일배울 점, 메모","link":"/2021/04/30/2021-prev/B11728/"},{"title":"B11729","text":"개요백준 문제 11729번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 120분https://www.acmicpc.net/problem/11729 문제하노이타워 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라.단, 이동 횟수는 최소가 되어야 한다. 코드123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;void hanoi(int n,int from,int by,int to) { if(n == 1) { cout &lt;&lt; from &lt;&lt; &quot; &quot; &lt;&lt; to &lt;&lt; &quot;\\n&quot;; } else { hanoi(n-1,from,to,by); cout &lt;&lt; from &lt;&lt; &quot; &quot; &lt;&lt; to &lt;&lt; &quot;\\n&quot;; hanoi(n-1,by,from,to); }}void solve(){ int N; int K; cin &gt;&gt; N; K = pow(2,N) -1; cout &lt;&lt; K &lt;&lt; &quot;\\n&quot;; hanoi(N,1,2,3);}int main(){ solve();} 풀이div and conquer방식은 어느정도 이해를 했다 생각하지만실제 문제에 도입해서 풀려고하니 잘 풀리지 않았다.(대부분 분할에 재귀형식으로 구현하는 것이 직관적임)또한 하노이 타워 자체의 해결법을 알지 못해 혼자 스스로 생각하다시간이 많이 걸렸다. 배울 점, 메모 하노이 타워같은 풀이방식은 내가 직접 찾기는 오래걸리고 힘들다.(어차피 규칙성에서 풀이를 찾는 것이라 크게 의미는 없다 봄) 1 따라서 이런 수학적이고 약간 노가다의 알고리즘은 찾아보는 것도 나쁘지 않다봄 한번 찾아본 것들은 잊어버리지 않는다는 생각으로 보고 반복하고 다시 생각해볼 것 하노이 타워 remind 3.1 n-1의 원반을 중간 기둥에 옮김 3.2 n번째 원반을 목적지에 옮김 3.3 중간 기둥에서 목적지까지 옮김어려웠던 점 여기서 중간 기둥으로 옮긴다는 것에는 다른 빈 기둥에 넣는다는 것을 내포한다. 이것을 재귀나 코드로 구현하기가 어려웠다(다른 빈 기둥을 찾는것도 이상했고 복잡하다 생각해서) 문제의 케이스를 따라하며 풀이를 생각하고 찾는데,이 방법은 문제의 케이스에만 fit만 코드가 나올 때도 있어(사실 아직은 실력이 부족해 대부분) 이부분 주의해야함.","link":"/2021/05/05/2021-prev/B11729/"},{"title":"B1373","text":"개요백준 문제 1373번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 10분https://www.acmicpc.net/problem/1373 문제2진수가 주어졌을 때, 8진수로 변환하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void solve(){ string binary; int countThree = 0; int digit = 1; int result = 0; cin &gt;&gt; binary; stack&lt;int&gt; s; for(int i=binary.size()-1;i&gt;=0;--i) { result += (binary[i] - '0') * digit; countThree++; digit*=2; if(countThree == 3) { s.push(result % 8); countThree = 0; result = 0; digit = 1; } } if(countThree != 0) { s.push(result % 8); } while(s.size()!= 0) { cout &lt;&lt; s.top(); s.pop(); }}int main(){ ios_base :: sync_with_stdio(0); cin.tie(0); solve();} 풀이2진수 입력 -&gt; 맨끝에서 부터 3개씩 카운트하며 결과값을 스택에 저장카운트가 3개가 되지 않은 경우 -&gt; 정확히 떨어지지 않은 경우이므로 예외로 결과값 저장저장된 스택에서 값 출력 = 정답 배울 점, 메모설계,문제 풀이법을 오래 생각할 수록 코드 작성은 간결해진다.물론 코드를 작성하는중에만 생각나는 것들도 있기는 하다.","link":"/2021/03/28/2021-prev/B1373/"},{"title":"B1517","text":"개요백준 문제 1517번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : ?분https://www.acmicpc.net/problem/1517 문제버블소트의 스왑을 몇번 일어나는지 체크하라 코드https://justicehui.github.io/ps/2019/04/23/BOJ1517/예전 코드가 간단해서 참고하였던 기억이 난다. 풀이문제 설명에서는 버블소트가 있어서 버블소트로 풀려고 할 수 있지만시간초과를 보면 그럴 이유가 없음따라서 분할 정복을 사용하게되면 곧 합병 정렬로 귀결됨합병 정렬의 과정 중에서 버블정렬의 오른쪽보다 왼쪽 값이 크면 스왑이 발생하는데,합병 정렬에서 conquer에서 왼쪽 값이 큰 경우 스왑 발생을 판단하면 되는 문제 배울 점, 메모학부 2학년 알고리즘 과제에서 풀어보라고 하여 풀어본 문제여서 기억이 났다.그때도 풀이를 보고 풀었던 기억이 난다.","link":"/2021/05/09/2021-prev/B1517/"},{"title":"B1780","text":"개요백준 문제 1780번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 120분https://www.acmicpc.net/problem/1780 문제N×N크기의 행렬로 표현되는 종이가 있다.종이의 각 칸에는 -1, 0, 1의 세 값 중 하나가 저장되어 있다.우리는 이 행렬을 적절한 크기로 자르려고 하는데, 이때 다음의 규칙에 따라 자르려고 한다. 만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.(1)이 아닌 경우에는 종이를 같은 크기의 9개의 종이로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오. 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 2200;int arrNum[MAX][MAX];int result[3];bool isSameNumberPaper(int startRow,int startCal,int divUnit){ int compareNum = arrNum[startRow][startCal]; for(int i=0;i&lt;divUnit;i++) { for(int j=0;j&lt;divUnit;j++) { if(arrNum[startRow+i][startCal+j] != compareNum) { return false; } } } return true;}void divAndConquer(int startRow,int startCal, int divUnit){ int val = arrNum[startRow][startCal]; if(divUnit &lt;= 1 || isSameNumberPaper(startRow,startCal,divUnit)) { if(val == -1) { result[2] += 1; } else { result[val] += 1; } } else { for(int i=0;i&lt; divUnit; i += divUnit/3) { for(int j=0;j&lt; divUnit; j += divUnit/3) { divAndConquer(i+startRow,j+startCal,divUnit/3); } } }}void solve(){ int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) { for(int j=0;j&lt;N;j++) { cin &gt;&gt; arrNum[i][j]; } } divAndConquer(0,0,N); cout &lt;&lt; result[2] &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; result[0] &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; result[1] &lt;&lt; &quot;\\n&quot;;}int main(){ fill_n(result,3,0); solve();} 풀이divide and conquer 배울 점, 메모문제를 잘못 이해해서 분할의 크기를 divide할 때 9로만 나눴는데당연히 3으로 나눴어야 했다.(문제 조건을 보라)","link":"/2021/05/05/2021-prev/B1780/"},{"title":"B1931","text":"개요백준 문제 1931번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 150분https://www.acmicpc.net/problem/1931 문제한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; using namespace std;int N;vector&lt;pair&lt;int,int&gt;&gt; v;vector&lt;pair&lt;int,int&gt;&gt; startV;void wrongSolve(){ cin &gt;&gt; N; int buf1,buf2,count = 1; for(int i=0;i&lt;N;i++) { cin &gt;&gt; buf1 &gt;&gt; buf2; startV.push_back({buf1,buf2}); } sort(startV.begin(),startV.end()); int selConfStart = startV[0].first; int selConfEnd = startV[0].second; //cout &lt;&lt; &quot;시작 : &quot; &lt;&lt; selConfStart &lt;&lt; &quot; &quot; &lt;&lt; selConfEnd &lt;&lt; endl; for (int i = 1; i &lt; startV.size(); ++i) { //지금 제일 작은 애 //하이재킹 if(selConfEnd &gt; startV[i].second) { selConfStart = startV[i].first; selConfEnd = startV[i].second; //cout &lt;&lt; selConfStart &lt;&lt; &quot; &quot; &lt;&lt; selConfEnd &lt;&lt; endl; } //종료 else if(selConfEnd &lt;= startV[i].first) { selConfStart = startV[i].first ; selConfEnd = startV[i].second; count++; //cout &lt;&lt; selConfStart &lt;&lt; &quot; &quot; &lt;&lt; selConfEnd &lt;&lt; endl; } } cout &lt;&lt; count;}bool sortbysec(const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp;b){ return (a.second &lt; b.second);}void rightSolve(){ cin &gt;&gt; N; int buf1,buf2; int count = 0; for(int i=0;i&lt;N;i++) { cin &gt;&gt; buf1 &gt;&gt; buf2; v.push_back(make_pair(buf1,buf2)); } sort(v.begin(),v.end()); sort(v.begin(),v.end(),sortbysec); int min = v[0].second; count++; for(int i=1;i&lt;N;i++) { if(v[i].first &gt;= min) { min = v[i].second; count++; } } cout &lt;&lt; count;}int main(){ wrongSolve();} 풀이 시작 시간으로 정렬 두가지 경우로 나눠서 생각 1 더 나은 (더 빨리 종료하는) 회의가 있으면 하이재킹 2 회의가 종료됐다면 카운트 배울 점, 메모위 두가지 접근은 처음부터 생각하는데 어려움이 없었다.그러나 코드 구현상에서 문제의 몇가지 조건에 맞지않는 등이 있어서 실패를 많이 했다하지만 다음날 다시 천천히 구현하니 꽤 쉽게 풀렸던 문제","link":"/2021/05/13/2021-prev/B1931/"},{"title":"B1992","text":"개요백준 문제 1992번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 60분https://www.acmicpc.net/problem/1992 문제위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며,이 영상을 쿼드 트리 구조를 이용하여 압축하면 “(0(0011)(0(0111)01)1)”로 표현된다.N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;string&gt; using namespace std;const int MAX = 64;int input[MAX][MAX];string tmp = &quot;&quot;;bool allPixelSame(int startRow,int startCal,int divUnit){ int comparePixel = input[startRow][startCal]; for(int i=0;i&lt;divUnit;i++) { for(int j=0;j&lt;divUnit;j++) { if(input[startRow+i][startCal+j] != comparePixel) { return false; } } } return true;}void quadTree(int startRow,int startCal,int divUnit){ if(divUnit == 1 || allPixelSame(startRow,startCal,divUnit)) { tmp.append(to_string(input[startRow][startCal])); } else { tmp.append(&quot;(&quot;); for(int i=0;i&lt;divUnit;i+= divUnit/2) { for(int j=0;j&lt;divUnit;j+=divUnit/2) { quadTree(startRow+i,startCal+j,divUnit/2); } } tmp.append(&quot;)&quot;); }}void solve(){ int N; char tmpInput; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) { for(int j=0;j&lt;N;j++) { cin &gt;&gt; tmpInput; input[i][j] = tmpInput - '0'; } } quadTree(0,0,N); cout &lt;&lt; tmp;}int main(){ solve();} 풀이전형적인 분할정복 문제이며 이전에 풀었던 문제와 유사한 유형이어서 쉽게 풀 수 있었음. 배울 점, 메모","link":"/2021/05/06/2021-prev/B1992/"},{"title":"B2089","text":"개요백준 문제 B2089번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : ?https://www.acmicpc.net/problem/2089 문제-2진법은 부호 없는 2진수로 표현이 된다. 2진법에서는 20, 21, 22, 23이 표현 되지만 -2진법에서는 (-2)0 = 1, (-2)1 = -2, (-2)2 = 4, (-2)3 = -8을 표현한다. 10진수로 1부터 표현하자면 1, 110, 111, 100, 101, 11010, 11011, 11000, 11001 등이다. 10진법의 수를 입력 받아서 -2진수를 출력하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;int init(){ int num; cin &gt;&gt; num; if(num == 0) { cout &lt;&lt; 0; } return num;}void solve(int num){ if(num == 0) { return; } if(num % -2 == 0) { solve(num / -2); cout &lt;&lt; 0; } else { solve((num-1) / -2); cout &lt;&lt; 1; } }int main(){ solve(init());} 풀이-2진법 =-2로 나눠서 나머지가 0이다 == 1 출력나머지가 0이 아니다 == 0 출력값 /= -2;하지만 나머지가 정확히 정수가 아닌 경우에 몫이 제대로 출력안됨따라서 (값-1) /= -2해줌 배울 점, 메모오랫동안 풀이 방법을 생각하지 못한문제..너무 머리나 시간을 안쓸려고하는게 아닐까","link":"/2021/04/01/2021-prev/B2089/"},{"title":"B2261","text":"개요백준 문제 2261번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 180분https://www.acmicpc.net/problem/2261 문제코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100000;const int INF = 987654321;int N;vector &lt;pair&lt;int,int&gt;&gt; v;int getCalDistance(int aIdx,int bIdx){ int ax = v.at(aIdx).first; int ay = v.at(aIdx).second; int bx = v.at(bIdx).first; int by = v.at(bIdx).second; return pow(bx - ax,2) + pow(by-ay,2);}int getMinDistanceInRange(int start,int end){ int result = INF; for(int i=start;i&lt;=end;i++) { for(int j=i+1;j&lt;=end;j++) { if(i!=j) { result = min(result,getCalDistance(i,j)); } } } return result;}int dist(pair&lt;int, int&gt; p1, pair&lt;int, int&gt; p2) { return pow(p1.first - p2.first, 2) + pow(p1.second - p2.second, 2);}int getIdxFromDLeft(int d,int mid){ int midX = v.at(mid).first -d; for(int i=0;i&lt;v.size();i++) { if(v.at(i).first &gt; midX) { return i; } } return -1;}int getIdxFromDRight(int d,int mid){ int midX = v.at(mid).first +d; for(int i=v.size()-1;i&gt;=0;i--) { if(v.at(i).first &lt; midX) { return i; } } return -1;}int binCal(int start,int end){ int result = INF; if(end - start + 1 &lt;= 3) { for (int i=start; i&lt;end; i++) { for (int j=i+1; j&lt;=end; j++) { result = min(result,dist(v[i], v[j])); } } } else { int mid= (start + end)/2; result = min(binCal(start,mid-1),binCal(mid+1,end)); vector&lt;pair&lt;int, int&gt;&gt; tmp; tmp.push_back({v[mid].second, v[mid].first}); for (int i=mid-1; i&gt;=start; i--) { if (dist({v[mid].first, 0}, {v[i].first, 0}) &gt;= result) { break; } tmp.push_back({v[i].second, v[i].first});// y축 순으로 정렬 } for (int i=mid+1; i&lt;=end; i++) { if (dist({v[mid].first, 0}, {v[i].first, 0}) &gt;= result) { break; } tmp.push_back({v[i].second, v[i].first});// y축 순으로 정렬 } sort(tmp.begin(), tmp.end());// y축 정렬 for (int i=0; i&lt;tmp.size()-1; i++) { for (int j=i+1; j&lt;tmp.size(); j++) { if (pow(tmp[i].first - tmp[j].first, 2) &gt;= result) { break; } result = min(result, dist(tmp[i], tmp[j])); } } } return result;}void solve(){ cin &gt;&gt; N; int x,y; for(int i=0;i&lt;N;i++) { cin &gt;&gt; x &gt;&gt; y; v.push_back(pair&lt;int,int&gt;(x,y)); } sort(v.begin(),v.end()); cout &lt;&lt; binCal(0,N-1);}int main(){ solve();} 풀이학부 3학년 알고리즘 시간 배운 문제로 분할정복을 이용해서 풀어야 하는 흐름은 다음과 같다. 전체 점에 대한 계산은 시간 문제가 크다. 분할 정복을 이용해서 계산할 점의 범위를 줄인 뒤 계산하여 합쳐야한다. 하지만 이 때 분할한 중심(이분 분할을 이용할 것이므로 중간값)을 기준으로 왼쪽과 오른쪽이 나뉘는데, 이 때 이 둘 사이의 거리가 큰 경우가 있을 수 있다. 배울 점, 메모이분 분할을 기준으로 푸는데 접근한 것은 풀이 방법을 알고 있어 쉽게 접근할 수 있었음.하지만 중간값에 대한 처리를 할 때 x축에 대해서 처리 한 것에 더해서 y축에 대해서도 처리해야 했는데 이 부분을 알 지 못했음.또한 중간값에 대한 점들은 새로운 tmp라는 벡터로 관리를 하는데 기존 벡터에 더할려고 했어서 복잡해진 경향이 있음.","link":"/2021/05/09/2021-prev/B2261/"},{"title":"B2447","text":"개요백준 문제 2447번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 120분https://www.acmicpc.net/problem/2447 문제N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다.예를 들어 N이 27의 패턴은 예제 출력 1과 같다. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;void printStar(int i,int j,int n){ if((i /n) % 3 == 1 &amp;&amp; (j /n)% 3 ==1) { printf(&quot; &quot;); } else { if(n == 1) { printf(&quot;*&quot;); } else { printStar(i,j,n/3); } }}void solve(){ int n; cin &gt;&gt; n; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { printStar(i,j,n); } cout &lt;&lt; endl; }}int main(){ solve();} 풀이 분할은 N에서 3씩 나누면서 3 혹은 1에서 출력을 하는 식으로 풀 수 있음. 출력은 한 줄씩 해야하는 방향으로 구현해야 함. 중간의 비어있는 별 모양은 예외처리 할 것. 배울 점, 메모분할에 있어서 출력하는 조건문이 처리를 어떻게 할 지 고민했는데 결국 1시간 반이 지나서 인터넷에서 찾아봤다.문제를 잘 풀기 위해서 다음을 계속 생각해야함. 분할을 어떻게 구현할 지 생각해야함. 1 이루고자 하는 목적을 분할함으로서 어떤 이점이 있는지 생각 어떤식으로 합칠 것인지 생각","link":"/2021/05/06/2021-prev/B2447/"},{"title":"B2448","text":"개요백준 문제 2448번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 150분https://www.acmicpc.net/problem/2448 문제예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요. 123456789101112131415161718192021222324 * * * ***** * * * * * * ***** ***** * * * * * * ***** ***** * * * * * * * * * * * * ***** ***** ***** ***** * * * * * * ***** ***** * * * * * * * * * * * * ***** ***** ***** ***** * * * * * * * * * * * * ***** ***** ***** ***** * * * * * * * * * * * * * * * * * * * * * * * * ***** ***** ***** ***** ***** ***** ***** ***** 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;char star[3072][6144];int N;void printStarResult(){ for(int i=0;i&lt;N;i++) { for(int j=0;j&lt;N*2-1;j++) { cout &lt;&lt; star[i][j]; } cout &lt;&lt; &quot;\\n&quot;; }}void printStar(int height,int x,int y){ if(height == 3) { star[y][x] = '*'; star[y+1][x-1] = '*'; star[y+1][x+1] = '*'; star[y+2][x-2] = '*'; star[y+2][x-1] = '*'; star[y+2][x] = '*'; star[y+2][x+1] = '*'; star[y+2][x+2] = '*'; //printStarResult(); return; } printStar(height/2,x,y); printStar(height/2,x-(height/2),y+(height/2)); printStar(height/2,x+(height/2),y+(height/2));}void solve(){ cin &gt;&gt; N; for(int i=0;i&lt;N;++i) { for (int j = 0; j &lt; 2* N; ++j) { if(j==2 * N -1) { star[i][j] = '\\0'; } else { star[i][j] = ' '; } } } printStar(N,N-1,0); printStarResult(); }int main(){ solve(); } 풀이분할정복임을 알고 접근하면큰 삼각형부터 작은 삼각형까지 분할해 나가서가장 작은 삼각형에서부터 별을 출력하면 되는 문제가장 작은 삼각형이 아닌 한개의 별을 출력하려고 하니 규칙이 너무 많았고 2시간이 초과되어 포기한 문제알고보니 삼각형을 중점적으로 분할하여 보면 보이는 문제였음. 배울 점, 메모아직 규칙을 찾는다던지 접근방식,처음에 알고리즘을 풀기위해 떠올린 아이디어가 잘 맞지않는다.풀이보고 약간 벽느껴졌음,,더 열심히 해야겠음","link":"/2021/05/09/2021-prev/B2448/"},{"title":"B2873","text":"개요백준 문제 2873번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : ?분https://www.acmicpc.net/problem/2873 문제상근이는 우리나라에서 가장 유명한 놀이 공원을 운영하고 있다. 이 놀이 공원은 야외에 있고, 다양한 롤러코스터가 많이 있다. 어느 날 벤치에 앉아있던 상근이는 커다란 황금을 발견한 기분이 들었다. 자신의 눈 앞에 보이는 이 부지를 구매해서 롤러코스터를 만든다면, 세상에서 가장 재미있는 롤러코스터를 만들 수 있다고 생각했다. 이 부지는 직사각형 모양이고, 상근이는 R행 C열의 표 모양으로 나누었다. 롤러코스터는 가장 왼쪽 위 칸에서 시작할 것이고, 가장 오른쪽 아래 칸에서 도착할 것이다. 롤러코스터는 현재 있는 칸과 위, 아래, 왼쪽, 오른쪽으로 인접한 칸으로 이동할 수 있다. 각 칸은 한 번 방문할 수 있고, 방문하지 않은 칸이 있어도 된다. 각 칸에는 그 칸을 지나갈 때, 탑승자가 얻을 수 있는 기쁨을 나타낸 숫자가 적혀있다. 롤러코스터를 탄 사람이 얻을 수 있는 기쁨은 지나간 칸의 기쁨의 합이다. 가장 큰 기쁨을 주는 롤러코스터는 어떻게 움직여야 하는지를 구하는 프로그램을 작성하시오. 코드1234567상근이는 우리나라에서 가장 유명한 놀이 공원을 운영하고 있다. 이 놀이 공원은 야외에 있고, 다양한 롤러코스터가 많이 있다.어느 날 벤치에 앉아있던 상근이는 커다란 황금을 발견한 기분이 들었다. 자신의 눈 앞에 보이는 이 부지를 구매해서 롤러코스터를 만든다면, 세상에서 가장 재미있는 롤러코스터를 만들 수 있다고 생각했다.이 부지는 직사각형 모양이고, 상근이는 R행 C열의 표 모양으로 나누었다. 롤러코스터는 가장 왼쪽 위 칸에서 시작할 것이고, 가장 오른쪽 아래 칸에서 도착할 것이다. 롤러코스터는 현재 있는 칸과 위, 아래, 왼쪽, 오른쪽으로 인접한 칸으로 이동할 수 있다. 각 칸은 한 번 방문할 수 있고, 방문하지 않은 칸이 있어도 된다.각 칸에는 그 칸을 지나갈 때, 탑승자가 얻을 수 있는 기쁨을 나타낸 숫자가 적혀있다. 롤러코스터를 탄 사람이 얻을 수 있는 기쁨은 지나간 칸의 기쁨의 합이다. 가장 큰 기쁨을 주는 롤러코스터는 어떻게 움직여야 하는지를 구하는 프로그램을 작성하시오. 풀이일단 당연히 모든 점을 순회할 수 있으면 가장 높은 점수가 나온다.그래서 모든 점을 순회가능한 경우에는 모두 순회하는데문제는 가로와 세로가 짝수인 경우에는 모두 순회할 수 없고 딱 한점을 피해서 가면 순회할 수 있어그 딱 한점을 피해서 가야한다.한 점을 피하는 건 우선 전체 점을 둘러보면서 가장 작은 점을 찾는다.그 뒤가 어려운데, 그 점의 좌표를 기준으로 최대한 많은 점을 순회하며 바로 왼쪽에 도달한 다음,왼쪽 아래 대각선으로 이동 오른쪽으로 이동 이후 마지막까지 순회하면 완성 배울 점, 메모나는 이 문제를 자력으로 풀진 못했다.모든 점을 순회하면 되는 두 경우는 생각했으나가로 세로가 짝수인 경우에는 안된다는 것을 찾지 못했고 검색을 통해알았지만, 실제로 구현할려고 생각하면 좀 복잡해서 이해하기도 힘들었다.이 문제를 풀면서 부족했던 능력은 문제를 읽고 케이스별을 놓침(문제에 대한 시간을 많이 쓰지 않음) - 여러 케이스를 직접 만들어서 하나씩 해야함 구현력 부족 - 많은 시간을 들여서 노력하는 수 밖에 없음","link":"/2021/05/17/2021-prev/B2873/"},{"title":"B2875","text":"개요백준 문제 2875번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 90분https://www.acmicpc.net/problem/2875 문제백준대학교에서는 대회에 나갈 때 2명의 여학생과 1명의 남학생이 팀을 결성해서 나가는 것이 원칙이다. (왜인지는 총장님께 여쭈어보는 것이 좋겠다.) 백준대학교는 뛰어난 인재들이 많아 올해에도 N명의 여학생과 M명의 남학생이 팀원을 찾고 있다. 대회에 참여하려는 학생들 중 K명은 반드시 인턴쉽 프로그램에 참여해야 한다. 인턴쉽에 참여하는 학생은 대회에 참여하지 못한다. 백준대학교에서는 뛰어난 인재들이 많기 때문에, 많은 팀을 만드는 것이 최선이다. 여러분은 여학생의 수 N, 남학생의 수 M, 인턴쉽에 참여해야하는 인원 K가 주어질 때 만들 수 있는 최대의 팀 수를 구하면 된다. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;int man,woman,objIntern;int minTeam = 0;void greedy(){ int intern = 0; while(objIntern != intern) { //여자 한명 빼도 팀 충족 if((woman-1)/2 &gt;= minTeam) { woman--; intern++; } //남자 한명 빼도 팀 충족 else if(man &gt; minTeam) { man--; intern++; } else if(woman/2 &gt; man) { //여자뺀다 woman--; intern++; minTeam--; } else { man--; intern++; minTeam--; } } cout &lt;&lt; minTeam; }void solve(){ cin &gt;&gt; woman &gt;&gt; man &gt;&gt; objIntern; minTeam = min(man,woman/2); greedy();}int main(){ solve();} 풀이 팀이 충족하는 한 남자나 여자를 빼는 것이 제일 큰 우선순위 팀이 충족하지 않는 경우에는 둘 중에 뺄 사람을 골라야함 -&gt; 최대한 팀이 깨지지 않게 (woman/2 &gt; man) 배울 점, 메모","link":"/2021/05/11/2021-prev/B2875/"},{"title":"CRF flowchart","text":"CRF Flowchartwill shown flowchart is CRF split by 3 part:get training data part,get feature part,optimize partsome optimze and specific mathmatical part was omitted FlowChartfollowing part is FlowChart CRF outlinethis flowchart shows splitted part CRF read corpusthis flowchart shows training data way CRF feature scanthis flowchart shows how to make feature CRF optimizethis flowchart shows optimize methods very simplelyfollowing:more specific but also there is no mathmatical explaination furture..continuing to study more specific parts…","link":"/2021/08/01/2021-prev/CRF%20flowchart/"},{"title":"Finishing Crawling Project","text":"title: Multiple Webpage Crawling Projectdate: 2020-08-21 12:21:46 To doi’m gonna try write posts with English from now on.all i have to do at this point… Project wrap-up with program packaging Some crawl Code modify Set Config Program modify Crawled Data Control IntroductionFinally Crawling Project is ended up.it took 2 month. but in fact the Program had a essential features after 1 month.anyway it finally ended, and i learned from this is importance of Object orientation,methodology, think from the user’s point of view. learned thingfor now, i think the first thing to do when designing program ispay attention at program’s structure.it is very important.if this ‘designing’ getting wrong,than your code and algorithm getting dirty as project go far,at maintance point of view, its hard to fix the codeand even knowing what does method have meaning is hard.so before all that, should carefully design algorithm.its contain efficiency at some way.i guess secondable important thing is Object-oriented.also carefully determine name of value is important.there are few rules that i get feel when i coding…those rules are easy to know but it’s sometimes its difficult to apply it to your code.the answer would be a practice i guess.. for nowbefore the univ starts,i should check my status andi think reminding learned before is nesessery.c language reviewing is first thing i’m gonna do.","link":"/2021/08/01/2021-prev/Finishing%20Crawling%20Project/"},{"title":"Pet Project Web 구상 - 넷플릭스, 왓챠의 프로그램 업데이트 현황 확인","text":"개요웹 기반 펫 프로젝트에 대한 목표를 정리한다.실제 상용화할지는 모르겠지만 웹 기반으로 한 몇가지 서비스를 만들어 보려고 한다.사실 이전에 회원가입, 로그인이 가능한 메모장 기능이 가능한 웹을 만들었는데 대충 만들어보니 다음과 같이 나왔다. 홈화면 메모 화면 이 프로젝트는 메모한 문서들을 pc가 바뀔때마다 pull, push 하는 것이 귀찮아서 웹에서 로그인으로 관리하면 좋겠다 생각해서 만든 프로젝트인데실제로 웹 서비스를 하지않아 사용은 안하고있는 상태이다. 여기에 추가로 넷플릭스나 왓챠에서 상영중인 프로그램들을 내가 즐겨찾기하고즐겨찾기한 프로그램들의 회차라던지 최근에 나온 회차같은 정보들을 한눈에 볼 수 있도록 하는 기능을 추가할려고 한다. 앞으로 이 기능을 추가한 것에 대한 트러블 슈팅이나 개발일지를 쓰려고 한다. 목표실제 상용화할지는 모르겠지만 웹 기반으로 한 몇가지 서비스를 만들어 보려고 한다. 넷플릭스, 왓챠에서 프로그램 목록을 검색(크롤링) 검색한 프로그램을 즐겨찾기 홈페이지에서는 항상 즐겨찾기한 프로그램들을 한눈에 볼 수 있음 만들게 된 계기 넷플릭스에서 프로그램 회차가 나온 현황을 알아볼려면직접 눌러서 확인하는것이 불편해서 만들고자 하였다.","link":"/2021/05/16/2021-prev/Pet-Project-Web/"},{"title":"B10815","text":"개요백준 문제 10815번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 30분https://www.acmicpc.net/problem/10815 문제숫자 카드는 정수 하나가 적혀져 있는 카드이다.상근이는 숫자 카드 N개를 가지고 있다.정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; num;void binSearch(int N){ int i,j; int M = 0; int mid = 0; int obj; int searched = 0; cin &gt;&gt; M; for(int k=0;k&lt;M;k++) { cin &gt;&gt; obj; if(k != 0) { cout &lt;&lt; &quot; &quot;; } i = 0; j = N-1; searched = false; while(i &lt;= j) { mid = (i + j)/2; if(obj == num[mid]) { searched = 1; break; } else if(obj &gt; num[mid]) { i = mid+1; } else { j = mid-1; } } cout &lt;&lt; searched; }}void solve(){ int obj; int val = 0; int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) { cin &gt;&gt; val; num.push_back(val); } sort(num.begin(),num.end()); binSearch(N);}int main(){ ios_base::sync_with_stdio(0); cin.tie(0); solve();} 풀이탐색 -&gt; 빠른 탐색 알고리즘인 이진 탐색 사용이진 탐색 사용할려면 정렬해야함 -&gt; 이번에는 sort() 사용 배울 점, 메모12ios_base::sync_with_stdio(0);cin.tie(0); 위 코드 안써서 시간초과남부담갖지말고 매일매일 하루를 채운다는 느낌","link":"/2021/04/30/2021-prev/b10815/"},{"title":"B10816","text":"개요백준 문제 10816번을 풀면서 어려웠던 점과 코드를 정리한다.소요 시간 : 60분https://www.acmicpc.net/problem/10816 문제숫자 카드는 정수 하나가 적혀져 있는 카드이다.상근이는 숫자 카드 N개를 가지고 있다.정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int arrMax = 500000;const int numMax = 10000001;int marking[arrMax];int sortedMark[arrMax];int num[arrMax];int plusNum[numMax];int minusNum[numMax]; // think as just * -1//1. 숫자 입력받음 //void binSearch(int N,int obj){ int i=0,j,mid; j = N; while(i &lt;= j) { mid = (i + j)/2; if(num[mid] == obj) { if(obj &lt; 0) { cout &lt;&lt; minusNum[obj * -1]; } else { cout &lt;&lt; plusNum[obj]; } return; } else if(num[mid] &gt; obj) { j = mid -1; } else if(num[mid] &lt; obj) { i = mid + 1; } } cout &lt;&lt; 0;}void solve(){ int N,M; cin &gt;&gt; N; fill_n(plusNum,numMax,0); fill_n(minusNum,numMax,0); for(int i=0;i&lt;N;i++) { cin &gt;&gt; num[i]; if(num[i] &lt; 0) { minusNum[num[i] * -1] += 1; } else { plusNum[num[i]] += 1; } } cin &gt;&gt; M; for(int i=0;i&lt;M;i++) { cin &gt;&gt; marking[i]; sortedMark[i] = marking[i]; } sort(num,num+N); for(int i=0;i&lt;M;i++) { if(i != 0) { cout &lt;&lt; &quot; &quot;; } binSearch(N,marking[i]); } /* for(int i=0;i&lt;M;i++) { if(marking[i] &lt; 0) { cout &lt;&lt; minusNum[-1 * marking[i]]; } else { cout &lt;&lt; plusNum[marking[i]]; } if(i != M-1) { cout &lt;&lt; &quot; &quot;; } } */ }int main(){ ios_base::sync_with_stdio(0); cin.tie(0); solve();} 풀이 10815번과 마찬가지로 입력에 대한 정렬 1 이번에는 입력시에 빈도수를 계산해야한다. 정렬 한 것에 대한 이분 탐색 탐색 결과에 대한 출력(빈도수) 피드백, 메모문제를 잘못이해했음문제 읽는데 더 시간을 들이자.","link":"/2021/04/30/2021-prev/b10816/"},{"title":"CRF checklist","text":"210106 reserch object CRF that can train and inference with kor it can completed by adding word, emjeol tokenizer it have specific needed input data set english, numbers are regarded as one representation character CRF that added mini batch batch so it can train with large data set it has to be with lots of modify CRF code it contains that each mini batch has its features that used by each mini batch ok with git especially branch, merge, requests etc code with TDD method it is good for make simple and looking good code and program structure always like i thought, coding with object-oriented way especially code is should have unit that made by methods","link":"/2021/08/01/2021-prev/checklist/"},{"title":"","text":"CRF란?, CRF 분석 title: CRF outlinetag: CRFcategory: CRF 목차 What is crf Definition What is crf for How to use crf How we can use crf at current project What is crf​ Definition crf(conditional random field)는 통계적 분석 모델 중 하나이다. 통계 모델은 sample data 생성 관련 통계적 가정을 구체화한 수학적 모델이다. 자연어처리 분야에서 자주 사용되는 선형 사슬 조건부 무작위장은 입력된 표본들에 대한 라벨들을 예측한다. 라벨 예측에 있어서 이웃 표본을 고려하여 예측하기 때문에 은닉 마르코프 모델의 대안이 된다. 은닉 마르코프 모델은 어떤 확률에 있어서 현재 확률이 현재 확률이 일어나기 직전의 확률에 영향을 받는 모델이다. What is crt for 따라서 이번 프로젝트에서도 통계 모델을 이용해 데이터의 라벨을 예측하는데 사용할 것으로 추측된다. How to use crfMethodcrf.py123456- callback()- generate_potential_table()- forward_backward()- calc_path_score()- log_likelihood()- gradient() crf.py - Class LinearChainCRF 123456789101112131415161718- _read_corpus()- _get_training_feature_data()- _estimate_parameters()- train()- test()- print_test_result()- inference()- viterbi()- save_model()- load()- feature_set()- label_array()- label_dic()- num_labels()- params()- squared_sigma()- training_data() bodyat this project, our goal is combine some our lib.so firstable thing i have to do isanalysis crf; so to know crf’s method.and furthermore, have to know things at future are:what is meaning of crf,how to use crf,how to combine with our libthe meaning of crf is on this posting sonext posting would be ‘how to use crt’","link":"/2021/08/01/2021-prev/crf/"},{"title":"CRF analysis","text":"Current Goalfor adding or modify CRF like adding korean tokinizer.and ultimately for combine lab individual libfirstable need to analysis CRF at perspective of methodi need to understand at code level but,in presentation, i should explain at input output level at each methods anyway, first goal is analysis CRF at input output level of methods.","link":"/2021/08/01/2021-prev/crf_analysis/"},{"title":"recently","text":"recentlythere was second semester final testwell…i think i will get grade that didn’t expectedof course i try to study hard at first.but while doing study i think what is meaning of this.this exam doesn’t do to me anything all i need is coding experiencei don’t wanna study for grade i want to study what i want and really need to me”of course there was some need to be study class andi did study at with my way but, yes i think i really don’t like examso i study that i need to know. ok it can be worst at perspective of score but i’m ok.doing study is ok but exam? i just fear of that. i need to win that feeling but didn’t this weekend.anyway i get some rest at last test weekend. play some video game..and getting sleep deeply..everybody need some refueling sometimes…but the important thing is that when refueling is over than should run again as soon as possiblefor now..i think again what is meaning of this and think what i want to and what i want to bewhat i need is something like lifegoal that helping me to stand up again.i just want to think free. i don’t wanna lock my thinking.i need perspective.","link":"/2021/08/01/2021-prev/recently/"},{"title":"Web Pet Project - Checklist","text":"checklist study js and make test webpage (doens’t need to be look good) i don't know js all literally. should study js from the start i don't like designing at all so.. i don’t know maybe just make seperated block and few explaning that what this part would have to do code backend(with python or java or C++ or C) adding function from ideas","link":"/2021/08/01/2021-prev/web%20pet%20project%20-%20checklist/"},{"title":"Web Pet Project - Outline","text":"outlinethe good way to improve develop skills and learning new technology is find somethingthat what you need when during implement project.the “that” is called as a “pet project”because the project you would start is grown by yourself’s demonds. so, i will try this “pet project”.something i want to make is have to got interlock with web and db with program.","link":"/2021/08/01/2021-prev/web%20pet%20project/"},{"title":"book report - 총균쇠","text":"집중력을 기르고싶어서 여러가지 방법 중 독서를 해볼려고 했는데 서울대학교 추천도서 중에서 무슨 책을 읽을까 고민하다 예전부터 읽어보고 싶었던 총균쇠를 읽기로 했다. 무슨 책인지 아예 배경지식이 없는 상태로 인류역사에 대한 책인지만 알고있는 상태로 읽기 시작했다. 하루에 50페이지씩 읽으려 노력했으며 약 2주에 걸쳐서 완독했다. 이 책을 읽으며 흥미로웠던 내용을 주로 정리해보려고한다. 지금까지 있었던 모든 인류 역사는 그렇게 흘러갈 수 밖에 없던 근본적인 이유가 존재한다지금껏 생각해보지는 않았던 것이기도하고 본 책의 도입부에서 던진 질문이기도 한 어떤 민족이 타 민족을 정복하고 전쟁에서 승리하는 것에 대한 근본적인 원인은 무엇인가 하는 질문이 이 책에서 말하고자 하는 바를 가장 많이 담고있다. 이 책을 읽기 전에는 나는 그 원인이 자원, 인종적인 차이로 인해서 승리한 것이 아닐까 혹은 그런 이유가 존재하는가 우연으로 이루어진 것이 아닌가 생각했었지만 본 책을 읽고나서는 이가 잘못된 생각임을 알게됐다. 근본적인 이유는 환경 그리고 식량 생산이 근본적인 이유이다.먼 과거 인간 사이의 전쟁에서 중요한 요인은 여러가지가 있지만 인구수도 중요한 요인이라고 할 수 있다. 그렇다면 어떤 그룹이 인구수를 빠르게 늘릴 수 있었을까 그것은 식량 생산을 먼저 시작한 종족이라고 저자는 말한다 우선 인류가 어느정도의 뇌 크기를 가지고 나서부터, 식량 생산을 먼저할 수 있게 되는 환경이 존재하는데 그 환경은 수렵채집에 너무 유리하지도 않고(수렵채집만 하고 정착을 하지 않을 수 있음) 처음에는 수렵채집으로 먹고살 수 있는 정도에 어느정도 환경을 파악하고 나서 식량생산에 유리한 환경(정착에 유리하게 사용할 수 있는 동식물이 풍부한)이 가장 정착을 하여 인구수를 늘리기에 적합하다는 것이다. 정착해서 식량 생산을 한 그 이후는?정착하여 식량 생산을 시작하면 인구가 폭발적으로 증가한다 인구가 증가하고 관리할것이 많아지면 중앙집권 체제가 들어서게 되고 문명의 기술자, 엘리트들을 먹여살릴 수 있게 되면서 기술이나 문자를 만들게 된다. 또한 아무래도 땅이 넓을수록 인구가 많아지기 좋고 인구가 많으면 기술자가 그만큼 많아지기 좋다 또한 유라시아같이 가로축이 긴 나라가 큰 국가를 형성하기가 좋은데 식물이 생존할때 같은 적도일수록 생존하기가 좋기때문에 국가를 이루기에 좋기 때문이다. 균정착을 하고 나서 동물을 가축화하고 나면 동물에서나 위생상에서 균에게 노출된다. 우선 균에 노출되고 나면 한번 해당 균이 휩쓴 뒤 그 지역에사는 사람들은 면역력을 가지게 된다. 이러한 면역력을 가진 사람들이 다른 지역에 가서 정복전쟁을 하게 되면 다른 지역에 사는 사람들은 면역력이 없기때문에 다시 그지역에서 균이 휩쓸기 마련이다. 요약이렇게 인간이 다른 인간을 정복한 것은 단지 그 인종이 우월해서 라던가 운이 좋아서라던가 같은 이유가 아닌 주어진 환경에 의해 유리하게 출발한 인간이 다른 인간을 정복하기가 좋았다고 요약할 수 있다. 그 외에 천재발명가의 발생은 영향이 없냐는 흥미로운 질문을 할 수 있는데, 저자는 발명이라는 것은 발명가 한명에 의해서만 어떠한 발명이 이루어지는 것이 아니고 시대적,사회적으로 필요로하는 물건에 대해서 주로 이루어지기가 쉽다는 것이기 때문에 이 천재 발명가 조차도 환경,시대가 중요함을 알 수 있다. 또한 만약 천재 발명가가 없었다면 그 나라가 흥하거나 망하거나 하는것에 대한 측량은 너무나 결과론적이기 때문에 현실적으로는 힘들다는 것이다. 마지막으로 중국에 관한 얘기가 흥미로워 이를 정리하고 독후감을 마치려한다. 중국은 유라시아의 다양한 식생물, 가로축으로 넓은 땅덩어리 실제로 다른 대륙의 인간보다 빠르고 유리하게 시작한 국가인데, 왜 어느순간부터 유럽에 뒤쳐졌는가 하는 내용에 대한 설명이 흥미로웠다 이것은 지리적으로 중국은 어느 시점부터 매우 빠르게 통합된 국가인데 그에반해 유럽은 지리적으로 분열된 국가이다. 너무 통합된 국가이기 때문에 오히려 혁신성을 해친 것이 중국의 케이스이다. 중앙집권체제에서 모든걸 결정해버린다고 생각하면 기술같은 혁신에 있어서 한쪽에 치우치기 좋기 때문에 이러한 현상이 생겼다고 볼 수 있다. 후기이렇게 단지 내가 흥미로웠던 내용을 중심으로 정리해보았다. 지식적인 측면, 논리적인 생각의 흐름에서 배움을 얻었다. 집중력도 처음 책을 읽을때는 5페이지 집중하기도 힘들었는데 읽다보니 집중력이 점차 느는것 같았다. 다음 책도 아마 서울대 추천도서중 고르지 않을까 생각하려고 한다. 이렇게 독후감을 마무리하려고 한다.","link":"/2021/09/09/2021-09/book-report-guns-germs-and-steel/"},{"title":"post_template","text":"[SpringBoot] 엔티티 내부 객체를 JPA 레포지토리에서 사용개요현재 단방향 관계로 사용중인 엔티티가 있는데, 이 엔티티에서 다른 테이블을 가르키는 객체를 이용해서 정렬을 하는 방법을 정리한다 Entity 관계현재 엔티티 관계는 다음과 같다 Board(게시글)와 Comment(댓글)에서 좋아요나 싫어요를 할 수 있는데 이를 각각 엔티티에서 담지 않고 Likes라는 테이블에서 관리를 하고자 하였다. 그렇게 할려고 각 Board와 Comment에서 Likes를 단방향관계로 묶어주었다 Entity 코드코드는 다음과 같으며 주석으로 **표시한 부분을 주로 보면 될 것 같다 12345678910111213141516171819202122232425262728293031323334353637383940@Getter@Setter@NoArgsConstructor@Entity@DynamicInsert@Table(name = &quot;BOARD&quot;)public class Board extends BaseTimeEntity{ //gallery 이름, user 이름으로 foregin key 설정할거임 이거 칼럼에서 추가하는거 있잖아 그거 하자 @Column(nullable = false, length = 45) private String gallery; @Column(nullable = false) private String user; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;content_idx&quot;) private Long contentIdx; @Column(nullable = false, length = 45) private String title; @Column(columnDefinition = &quot;text&quot;, nullable = false) private String content; //*********************************************** @OneToOne(cascade = CascadeType.ALL) private Likes likes; //*********************************************** @Column(length = 80, nullable = false) private String password; @Column(columnDefinition = &quot;tinyint(1) default 0&quot;, name = &quot;is_logged_user&quot;,nullable = false) private Long isLoggedUser; //이하생략} 12345678910111213141516171819202122232425262728293031323334353637@Getter@Entity@EntityListeners(AuditingEntityListener.class)@DynamicInsert@Table(name = &quot;COMMENT&quot;)@NoArgsConstructorpublic class Comment extends BaseTimeEntity{ @Id @Column(name = &quot;comment_idx&quot;) @GeneratedValue(strategy = GenerationType.IDENTITY) Long contentIdx; @Column(name = &quot;board_idx&quot;,nullable = false) Long boardIdx; @Column(nullable = false) String gallery; @Column(nullable = false) String user; @Column(nullable = false) String content; @Column(name = &quot;comment_password&quot;,nullable = false,length = 80) String commentPassword; @Column(columnDefinition = &quot;tinyint(1) default 0&quot;,nullable = false,name = &quot;is_logged_user&quot;) Long isLogged; //*********************************************** @OneToOne(cascade = CascadeType.ALL) private Likes likes; //*********************************************** //이하생략 1234567891011121314151617181920212223@Entity@Getter@NoArgsConstructor@DynamicInsert@Table(name= &quot;likes&quot;)@IdClass(LikesID.class)public class Likes implements Serializable{ @Column(name = &quot;is_comment&quot;) @Id private boolean isComment; //board,comment 둘의 개추들 모두 담음 @Id @Column(name = &quot;content_idx&quot;,nullable = false) private Long contentIdx; @Column(columnDefinition = &quot;bigint default 0&quot;) private Long like; @Column(columnDefinition = &quot;bigint default 0&quot;) private Long dislike; Repository에서 사용12345public interface BoardRepository extends JpaRepository&lt;Board, Long&gt;{ List&lt;Board&gt; findTop10ByOrderByLikesLikeDesc();} findTop10 : 정렬 기준이 가장 높은 10가지를 가져온다 OrderByLikesLike : Board 엔티티의 Likes 객체의 Like를 기준으로 내림차순 정렬을 한다 마무리레포지토리에서 객체안의 값을 기준으로 정렬할려면 어떻게 해야하지? 고민했는데 LikesLike처럼 이어서 사용하면 되는 것이었다 참고https://stackoverflow.com/questions/55579240/spring-data-find-by-property-of-a-nested-object/55579268","link":"/2021/09/18/2021-09/%5BSpringBoot%5D%20using%20entity%20object%20in%20jpa%20repository/"}],"tags":[{"name":"pet project","slug":"pet-project","link":"/tags/pet-project/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"pet_project","slug":"pet-project","link":"/tags/pet-project/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"write","slug":"write","link":"/tags/write/"},{"name":"CRF","slug":"CRF","link":"/tags/CRF/"},{"name":"web pet project","slug":"web-pet-project","link":"/tags/web-pet-project/"},{"name":"book_report","slug":"book-report","link":"/tags/book-report/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"jpa","slug":"jpa","link":"/tags/jpa/"}],"categories":[{"name":"pet project","slug":"pet-project","link":"/categories/pet-project/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"},{"name":"write","slug":"write","link":"/categories/write/"},{"name":"CRF","slug":"CRF","link":"/categories/CRF/"},{"name":"pet project:web","slug":"pet-project/pet-project-web","link":"/categories/pet-project/pet-project-web/"}]}